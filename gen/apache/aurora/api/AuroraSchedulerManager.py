#
# Autogenerated by Thrift Compiler (1.0.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import gen.apache.aurora.api.ReadOnlyScheduler
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(gen.apache.aurora.api.ReadOnlyScheduler.Iface):
  def createJob(self, description, lock, session):
    """
    Creates a new job.  The request will be denied if a job with the provided name already exists
    in the cluster.

    Parameters:
     - description
     - lock
     - session
    """
    pass

  def scheduleCronJob(self, description, lock, session):
    """
    Enters a job into the cron schedule, without actually starting the job.
    If the job is already present in the schedule, this will update the schedule entry with the new
    configuration.

    Parameters:
     - description
     - lock
     - session
    """
    pass

  def descheduleCronJob(self, job, lock, session):
    """
    Removes a job from the cron schedule. The request will be denied if the job was not previously
    scheduled with scheduleCronJob.

    Parameters:
     - job
     - lock
     - session
    """
    pass

  def startCronJob(self, job, session):
    """
    Starts a cron job immediately.  The request will be denied if the specified job does not
    exist for the role account, or the job is not a cron job.

    Parameters:
     - job
     - session
    """
    pass

  def restartShards(self, job, shardIds, lock, session):
    """
    Restarts a batch of shards.

    Parameters:
     - job
     - shardIds
     - lock
     - session
    """
    pass

  def killTasks(self, query, lock, session):
    """
    Initiates a kill on tasks.

    Parameters:
     - query
     - lock
     - session
    """
    pass

  def addInstances(self, config, lock, session):
    """
    Adds new instances specified by the AddInstancesConfig. A job represented by the JobKey must be
    protected by Lock.

    Parameters:
     - config
     - lock
     - session
    """
    pass

  def acquireLock(self, lockKey, session):
    """
    Creates and saves a new Lock instance guarding against multiple mutating operations within the
    context defined by LockKey.

    Parameters:
     - lockKey
     - session
    """
    pass

  def releaseLock(self, lock, validation, session):
    """
    Releases the lock acquired earlier in acquireLock call.

    Parameters:
     - lock
     - validation
     - session
    """
    pass

  def replaceCronTemplate(self, config, lock, session):
    """
    Replaces the template (configuration) for the existing cron job.
    The cron job template (configuration) must exist for the call to succeed.

    Parameters:
     - config
     - lock
     - session
    """
    pass

  def startJobUpdate(self, request, message, session):
    """
    Starts update of the existing service job.

    Parameters:
     - request: A description of how to change the job.
     - message: A user-specified message to include with the induced job update state change.
     - session
    """
    pass

  def pauseJobUpdate(self, key, message, session):
    """
    Pauses the specified job update. Can be resumed by resumeUpdate call.

    Parameters:
     - key: The update to pause.
     - message: A user-specified message to include with the induced job update state change.
     - session
    """
    pass

  def resumeJobUpdate(self, key, message, session):
    """
    Resumes progress of a previously paused job update.

    Parameters:
     - key: The update to resume.
     - message: A user-specified message to include with the induced job update state change.
     - session
    """
    pass

  def abortJobUpdate(self, key, message, session):
    """
    Permanently aborts the job update. Does not remove the update history.

    Parameters:
     - key: The update to abort.
     - message: A user-specified message to include with the induced job update state change.
     - session
    """
    pass

  def pulseJobUpdate(self, key, session):
    """
    Allows progress of the job update in case blockIfNoPulsesAfterMs is specified in
    JobUpdateSettings. Unblocks progress if the update was previously blocked.
    Responds with ResponseCode.INVALID_REQUEST in case an unknown update key is specified.

    Parameters:
     - key
     - session
    """
    pass


class Client(gen.apache.aurora.api.ReadOnlyScheduler.Client, Iface):
  def __init__(self, iprot, oprot=None):
    gen.apache.aurora.api.ReadOnlyScheduler.Client.__init__(self, iprot, oprot)

  def createJob(self, description, lock, session):
    """
    Creates a new job.  The request will be denied if a job with the provided name already exists
    in the cluster.

    Parameters:
     - description
     - lock
     - session
    """
    self.send_createJob(description, lock, session)
    return self.recv_createJob()

  def send_createJob(self, description, lock, session):
    self._oprot.writeMessageBegin('createJob', TMessageType.CALL, self._seqid)
    args = createJob_args()
    args.description = description
    args.lock = lock
    args.session = session
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createJob(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = createJob_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createJob failed: unknown result")

  def scheduleCronJob(self, description, lock, session):
    """
    Enters a job into the cron schedule, without actually starting the job.
    If the job is already present in the schedule, this will update the schedule entry with the new
    configuration.

    Parameters:
     - description
     - lock
     - session
    """
    self.send_scheduleCronJob(description, lock, session)
    return self.recv_scheduleCronJob()

  def send_scheduleCronJob(self, description, lock, session):
    self._oprot.writeMessageBegin('scheduleCronJob', TMessageType.CALL, self._seqid)
    args = scheduleCronJob_args()
    args.description = description
    args.lock = lock
    args.session = session
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_scheduleCronJob(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = scheduleCronJob_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "scheduleCronJob failed: unknown result")

  def descheduleCronJob(self, job, lock, session):
    """
    Removes a job from the cron schedule. The request will be denied if the job was not previously
    scheduled with scheduleCronJob.

    Parameters:
     - job
     - lock
     - session
    """
    self.send_descheduleCronJob(job, lock, session)
    return self.recv_descheduleCronJob()

  def send_descheduleCronJob(self, job, lock, session):
    self._oprot.writeMessageBegin('descheduleCronJob', TMessageType.CALL, self._seqid)
    args = descheduleCronJob_args()
    args.job = job
    args.lock = lock
    args.session = session
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_descheduleCronJob(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = descheduleCronJob_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "descheduleCronJob failed: unknown result")

  def startCronJob(self, job, session):
    """
    Starts a cron job immediately.  The request will be denied if the specified job does not
    exist for the role account, or the job is not a cron job.

    Parameters:
     - job
     - session
    """
    self.send_startCronJob(job, session)
    return self.recv_startCronJob()

  def send_startCronJob(self, job, session):
    self._oprot.writeMessageBegin('startCronJob', TMessageType.CALL, self._seqid)
    args = startCronJob_args()
    args.job = job
    args.session = session
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startCronJob(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = startCronJob_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "startCronJob failed: unknown result")

  def restartShards(self, job, shardIds, lock, session):
    """
    Restarts a batch of shards.

    Parameters:
     - job
     - shardIds
     - lock
     - session
    """
    self.send_restartShards(job, shardIds, lock, session)
    return self.recv_restartShards()

  def send_restartShards(self, job, shardIds, lock, session):
    self._oprot.writeMessageBegin('restartShards', TMessageType.CALL, self._seqid)
    args = restartShards_args()
    args.job = job
    args.shardIds = shardIds
    args.lock = lock
    args.session = session
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_restartShards(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = restartShards_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "restartShards failed: unknown result")

  def killTasks(self, query, lock, session):
    """
    Initiates a kill on tasks.

    Parameters:
     - query
     - lock
     - session
    """
    self.send_killTasks(query, lock, session)
    return self.recv_killTasks()

  def send_killTasks(self, query, lock, session):
    self._oprot.writeMessageBegin('killTasks', TMessageType.CALL, self._seqid)
    args = killTasks_args()
    args.query = query
    args.lock = lock
    args.session = session
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_killTasks(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = killTasks_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "killTasks failed: unknown result")

  def addInstances(self, config, lock, session):
    """
    Adds new instances specified by the AddInstancesConfig. A job represented by the JobKey must be
    protected by Lock.

    Parameters:
     - config
     - lock
     - session
    """
    self.send_addInstances(config, lock, session)
    return self.recv_addInstances()

  def send_addInstances(self, config, lock, session):
    self._oprot.writeMessageBegin('addInstances', TMessageType.CALL, self._seqid)
    args = addInstances_args()
    args.config = config
    args.lock = lock
    args.session = session
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addInstances(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = addInstances_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addInstances failed: unknown result")

  def acquireLock(self, lockKey, session):
    """
    Creates and saves a new Lock instance guarding against multiple mutating operations within the
    context defined by LockKey.

    Parameters:
     - lockKey
     - session
    """
    self.send_acquireLock(lockKey, session)
    return self.recv_acquireLock()

  def send_acquireLock(self, lockKey, session):
    self._oprot.writeMessageBegin('acquireLock', TMessageType.CALL, self._seqid)
    args = acquireLock_args()
    args.lockKey = lockKey
    args.session = session
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_acquireLock(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = acquireLock_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "acquireLock failed: unknown result")

  def releaseLock(self, lock, validation, session):
    """
    Releases the lock acquired earlier in acquireLock call.

    Parameters:
     - lock
     - validation
     - session
    """
    self.send_releaseLock(lock, validation, session)
    return self.recv_releaseLock()

  def send_releaseLock(self, lock, validation, session):
    self._oprot.writeMessageBegin('releaseLock', TMessageType.CALL, self._seqid)
    args = releaseLock_args()
    args.lock = lock
    args.validation = validation
    args.session = session
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_releaseLock(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = releaseLock_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "releaseLock failed: unknown result")

  def replaceCronTemplate(self, config, lock, session):
    """
    Replaces the template (configuration) for the existing cron job.
    The cron job template (configuration) must exist for the call to succeed.

    Parameters:
     - config
     - lock
     - session
    """
    self.send_replaceCronTemplate(config, lock, session)
    return self.recv_replaceCronTemplate()

  def send_replaceCronTemplate(self, config, lock, session):
    self._oprot.writeMessageBegin('replaceCronTemplate', TMessageType.CALL, self._seqid)
    args = replaceCronTemplate_args()
    args.config = config
    args.lock = lock
    args.session = session
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_replaceCronTemplate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = replaceCronTemplate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "replaceCronTemplate failed: unknown result")

  def startJobUpdate(self, request, message, session):
    """
    Starts update of the existing service job.

    Parameters:
     - request: A description of how to change the job.
     - message: A user-specified message to include with the induced job update state change.
     - session
    """
    self.send_startJobUpdate(request, message, session)
    return self.recv_startJobUpdate()

  def send_startJobUpdate(self, request, message, session):
    self._oprot.writeMessageBegin('startJobUpdate', TMessageType.CALL, self._seqid)
    args = startJobUpdate_args()
    args.request = request
    args.message = message
    args.session = session
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startJobUpdate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = startJobUpdate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "startJobUpdate failed: unknown result")

  def pauseJobUpdate(self, key, message, session):
    """
    Pauses the specified job update. Can be resumed by resumeUpdate call.

    Parameters:
     - key: The update to pause.
     - message: A user-specified message to include with the induced job update state change.
     - session
    """
    self.send_pauseJobUpdate(key, message, session)
    return self.recv_pauseJobUpdate()

  def send_pauseJobUpdate(self, key, message, session):
    self._oprot.writeMessageBegin('pauseJobUpdate', TMessageType.CALL, self._seqid)
    args = pauseJobUpdate_args()
    args.key = key
    args.message = message
    args.session = session
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_pauseJobUpdate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = pauseJobUpdate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "pauseJobUpdate failed: unknown result")

  def resumeJobUpdate(self, key, message, session):
    """
    Resumes progress of a previously paused job update.

    Parameters:
     - key: The update to resume.
     - message: A user-specified message to include with the induced job update state change.
     - session
    """
    self.send_resumeJobUpdate(key, message, session)
    return self.recv_resumeJobUpdate()

  def send_resumeJobUpdate(self, key, message, session):
    self._oprot.writeMessageBegin('resumeJobUpdate', TMessageType.CALL, self._seqid)
    args = resumeJobUpdate_args()
    args.key = key
    args.message = message
    args.session = session
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_resumeJobUpdate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = resumeJobUpdate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "resumeJobUpdate failed: unknown result")

  def abortJobUpdate(self, key, message, session):
    """
    Permanently aborts the job update. Does not remove the update history.

    Parameters:
     - key: The update to abort.
     - message: A user-specified message to include with the induced job update state change.
     - session
    """
    self.send_abortJobUpdate(key, message, session)
    return self.recv_abortJobUpdate()

  def send_abortJobUpdate(self, key, message, session):
    self._oprot.writeMessageBegin('abortJobUpdate', TMessageType.CALL, self._seqid)
    args = abortJobUpdate_args()
    args.key = key
    args.message = message
    args.session = session
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_abortJobUpdate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = abortJobUpdate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "abortJobUpdate failed: unknown result")

  def pulseJobUpdate(self, key, session):
    """
    Allows progress of the job update in case blockIfNoPulsesAfterMs is specified in
    JobUpdateSettings. Unblocks progress if the update was previously blocked.
    Responds with ResponseCode.INVALID_REQUEST in case an unknown update key is specified.

    Parameters:
     - key
     - session
    """
    self.send_pulseJobUpdate(key, session)
    return self.recv_pulseJobUpdate()

  def send_pulseJobUpdate(self, key, session):
    self._oprot.writeMessageBegin('pulseJobUpdate', TMessageType.CALL, self._seqid)
    args = pulseJobUpdate_args()
    args.key = key
    args.session = session
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_pulseJobUpdate(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = pulseJobUpdate_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "pulseJobUpdate failed: unknown result")


class Processor(gen.apache.aurora.api.ReadOnlyScheduler.Processor, Iface, TProcessor):
  def __init__(self, handler):
    gen.apache.aurora.api.ReadOnlyScheduler.Processor.__init__(self, handler)
    self._processMap["createJob"] = Processor.process_createJob
    self._processMap["scheduleCronJob"] = Processor.process_scheduleCronJob
    self._processMap["descheduleCronJob"] = Processor.process_descheduleCronJob
    self._processMap["startCronJob"] = Processor.process_startCronJob
    self._processMap["restartShards"] = Processor.process_restartShards
    self._processMap["killTasks"] = Processor.process_killTasks
    self._processMap["addInstances"] = Processor.process_addInstances
    self._processMap["acquireLock"] = Processor.process_acquireLock
    self._processMap["releaseLock"] = Processor.process_releaseLock
    self._processMap["replaceCronTemplate"] = Processor.process_replaceCronTemplate
    self._processMap["startJobUpdate"] = Processor.process_startJobUpdate
    self._processMap["pauseJobUpdate"] = Processor.process_pauseJobUpdate
    self._processMap["resumeJobUpdate"] = Processor.process_resumeJobUpdate
    self._processMap["abortJobUpdate"] = Processor.process_abortJobUpdate
    self._processMap["pulseJobUpdate"] = Processor.process_pulseJobUpdate

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_createJob(self, seqid, iprot, oprot):
    args = createJob_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createJob_result()
    result.success = self._handler.createJob(args.description, args.lock, args.session)
    oprot.writeMessageBegin("createJob", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_scheduleCronJob(self, seqid, iprot, oprot):
    args = scheduleCronJob_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = scheduleCronJob_result()
    result.success = self._handler.scheduleCronJob(args.description, args.lock, args.session)
    oprot.writeMessageBegin("scheduleCronJob", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_descheduleCronJob(self, seqid, iprot, oprot):
    args = descheduleCronJob_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = descheduleCronJob_result()
    result.success = self._handler.descheduleCronJob(args.job, args.lock, args.session)
    oprot.writeMessageBegin("descheduleCronJob", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_startCronJob(self, seqid, iprot, oprot):
    args = startCronJob_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startCronJob_result()
    result.success = self._handler.startCronJob(args.job, args.session)
    oprot.writeMessageBegin("startCronJob", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_restartShards(self, seqid, iprot, oprot):
    args = restartShards_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = restartShards_result()
    result.success = self._handler.restartShards(args.job, args.shardIds, args.lock, args.session)
    oprot.writeMessageBegin("restartShards", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_killTasks(self, seqid, iprot, oprot):
    args = killTasks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = killTasks_result()
    result.success = self._handler.killTasks(args.query, args.lock, args.session)
    oprot.writeMessageBegin("killTasks", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addInstances(self, seqid, iprot, oprot):
    args = addInstances_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addInstances_result()
    result.success = self._handler.addInstances(args.config, args.lock, args.session)
    oprot.writeMessageBegin("addInstances", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_acquireLock(self, seqid, iprot, oprot):
    args = acquireLock_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = acquireLock_result()
    result.success = self._handler.acquireLock(args.lockKey, args.session)
    oprot.writeMessageBegin("acquireLock", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_releaseLock(self, seqid, iprot, oprot):
    args = releaseLock_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = releaseLock_result()
    result.success = self._handler.releaseLock(args.lock, args.validation, args.session)
    oprot.writeMessageBegin("releaseLock", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_replaceCronTemplate(self, seqid, iprot, oprot):
    args = replaceCronTemplate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = replaceCronTemplate_result()
    result.success = self._handler.replaceCronTemplate(args.config, args.lock, args.session)
    oprot.writeMessageBegin("replaceCronTemplate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_startJobUpdate(self, seqid, iprot, oprot):
    args = startJobUpdate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startJobUpdate_result()
    result.success = self._handler.startJobUpdate(args.request, args.message, args.session)
    oprot.writeMessageBegin("startJobUpdate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_pauseJobUpdate(self, seqid, iprot, oprot):
    args = pauseJobUpdate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = pauseJobUpdate_result()
    result.success = self._handler.pauseJobUpdate(args.key, args.message, args.session)
    oprot.writeMessageBegin("pauseJobUpdate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_resumeJobUpdate(self, seqid, iprot, oprot):
    args = resumeJobUpdate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = resumeJobUpdate_result()
    result.success = self._handler.resumeJobUpdate(args.key, args.message, args.session)
    oprot.writeMessageBegin("resumeJobUpdate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_abortJobUpdate(self, seqid, iprot, oprot):
    args = abortJobUpdate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = abortJobUpdate_result()
    result.success = self._handler.abortJobUpdate(args.key, args.message, args.session)
    oprot.writeMessageBegin("abortJobUpdate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_pulseJobUpdate(self, seqid, iprot, oprot):
    args = pulseJobUpdate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = pulseJobUpdate_result()
    result.success = self._handler.pulseJobUpdate(args.key, args.session)
    oprot.writeMessageBegin("pulseJobUpdate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class createJob_args:
  """
  Attributes:
   - description
   - lock
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'description', (JobConfiguration, JobConfiguration.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'session', (SessionKey, SessionKey.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'lock', (Lock, Lock.thrift_spec), None, ), # 3
  )

  def __init__(self, description=None, lock=None, session=None,):
    self.description = description
    self.lock = lock
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.description = JobConfiguration()
          self.description.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.lock = Lock()
          self.lock.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.session = SessionKey()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createJob_args')
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRUCT, 1)
      self.description.write(oprot)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 2)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.lock is not None:
      oprot.writeFieldBegin('lock', TType.STRUCT, 3)
      self.lock.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.description)
    value = (value * 31) ^ hash(self.lock)
    value = (value * 31) ^ hash(self.session)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createJob_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Response, Response.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Response()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createJob_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class scheduleCronJob_args:
  """
  Attributes:
   - description
   - lock
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'description', (JobConfiguration, JobConfiguration.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'session', (SessionKey, SessionKey.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'lock', (Lock, Lock.thrift_spec), None, ), # 3
  )

  def __init__(self, description=None, lock=None, session=None,):
    self.description = description
    self.lock = lock
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.description = JobConfiguration()
          self.description.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.lock = Lock()
          self.lock.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.session = SessionKey()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('scheduleCronJob_args')
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRUCT, 1)
      self.description.write(oprot)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 2)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.lock is not None:
      oprot.writeFieldBegin('lock', TType.STRUCT, 3)
      self.lock.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.description)
    value = (value * 31) ^ hash(self.lock)
    value = (value * 31) ^ hash(self.session)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class scheduleCronJob_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Response, Response.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Response()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('scheduleCronJob_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class descheduleCronJob_args:
  """
  Attributes:
   - job
   - lock
   - session
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRUCT, 'session', (SessionKey, SessionKey.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'lock', (Lock, Lock.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'job', (JobKey, JobKey.thrift_spec), None, ), # 4
  )

  def __init__(self, job=None, lock=None, session=None,):
    self.job = job
    self.lock = lock
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 4:
        if ftype == TType.STRUCT:
          self.job = JobKey()
          self.job.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.lock = Lock()
          self.lock.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.session = SessionKey()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('descheduleCronJob_args')
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 2)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.lock is not None:
      oprot.writeFieldBegin('lock', TType.STRUCT, 3)
      self.lock.write(oprot)
      oprot.writeFieldEnd()
    if self.job is not None:
      oprot.writeFieldBegin('job', TType.STRUCT, 4)
      self.job.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.job)
    value = (value * 31) ^ hash(self.lock)
    value = (value * 31) ^ hash(self.session)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class descheduleCronJob_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Response, Response.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Response()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('descheduleCronJob_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startCronJob_args:
  """
  Attributes:
   - job
   - session
  """

  thrift_spec = (
    None, # 0
    None, # 1
    None, # 2
    (3, TType.STRUCT, 'session', (SessionKey, SessionKey.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'job', (JobKey, JobKey.thrift_spec), None, ), # 4
  )

  def __init__(self, job=None, session=None,):
    self.job = job
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 4:
        if ftype == TType.STRUCT:
          self.job = JobKey()
          self.job.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.session = SessionKey()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startCronJob_args')
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 3)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.job is not None:
      oprot.writeFieldBegin('job', TType.STRUCT, 4)
      self.job.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.job)
    value = (value * 31) ^ hash(self.session)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startCronJob_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Response, Response.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Response()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startCronJob_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class restartShards_args:
  """
  Attributes:
   - job
   - shardIds
   - lock
   - session
  """

  thrift_spec = (
    None, # 0
    None, # 1
    None, # 2
    (3, TType.SET, 'shardIds', (TType.I32,None), None, ), # 3
    (4, TType.STRUCT, 'session', (SessionKey, SessionKey.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'job', (JobKey, JobKey.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'lock', (Lock, Lock.thrift_spec), None, ), # 6
  )

  def __init__(self, job=None, shardIds=None, lock=None, session=None,):
    self.job = job
    self.shardIds = shardIds
    self.lock = lock
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 5:
        if ftype == TType.STRUCT:
          self.job = JobKey()
          self.job.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.shardIds = set()
          (_etype287, _size284) = iprot.readSetBegin()
          for _i288 in range(_size284):
            _elem289 = iprot.readI32()
            self.shardIds.add(_elem289)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.lock = Lock()
          self.lock.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.session = SessionKey()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('restartShards_args')
    if self.shardIds is not None:
      oprot.writeFieldBegin('shardIds', TType.SET, 3)
      oprot.writeSetBegin(TType.I32, len(self.shardIds))
      for iter290 in self.shardIds:
        oprot.writeI32(iter290)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 4)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.job is not None:
      oprot.writeFieldBegin('job', TType.STRUCT, 5)
      self.job.write(oprot)
      oprot.writeFieldEnd()
    if self.lock is not None:
      oprot.writeFieldBegin('lock', TType.STRUCT, 6)
      self.lock.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.job)
    value = (value * 31) ^ hash(self.shardIds)
    value = (value * 31) ^ hash(self.lock)
    value = (value * 31) ^ hash(self.session)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class restartShards_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Response, Response.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Response()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('restartShards_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class killTasks_args:
  """
  Attributes:
   - query
   - lock
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'query', (TaskQuery, TaskQuery.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'session', (SessionKey, SessionKey.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'lock', (Lock, Lock.thrift_spec), None, ), # 3
  )

  def __init__(self, query=None, lock=None, session=None,):
    self.query = query
    self.lock = lock
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.query = TaskQuery()
          self.query.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.lock = Lock()
          self.lock.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.session = SessionKey()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('killTasks_args')
    if self.query is not None:
      oprot.writeFieldBegin('query', TType.STRUCT, 1)
      self.query.write(oprot)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 2)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.lock is not None:
      oprot.writeFieldBegin('lock', TType.STRUCT, 3)
      self.lock.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.query)
    value = (value * 31) ^ hash(self.lock)
    value = (value * 31) ^ hash(self.session)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class killTasks_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Response, Response.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Response()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('killTasks_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addInstances_args:
  """
  Attributes:
   - config
   - lock
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'config', (AddInstancesConfig, AddInstancesConfig.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'lock', (Lock, Lock.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'session', (SessionKey, SessionKey.thrift_spec), None, ), # 3
  )

  def __init__(self, config=None, lock=None, session=None,):
    self.config = config
    self.lock = lock
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.config = AddInstancesConfig()
          self.config.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.lock = Lock()
          self.lock.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.session = SessionKey()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addInstances_args')
    if self.config is not None:
      oprot.writeFieldBegin('config', TType.STRUCT, 1)
      self.config.write(oprot)
      oprot.writeFieldEnd()
    if self.lock is not None:
      oprot.writeFieldBegin('lock', TType.STRUCT, 2)
      self.lock.write(oprot)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 3)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.config)
    value = (value * 31) ^ hash(self.lock)
    value = (value * 31) ^ hash(self.session)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addInstances_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Response, Response.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Response()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addInstances_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acquireLock_args:
  """
  Attributes:
   - lockKey
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'lockKey', (LockKey, LockKey.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'session', (SessionKey, SessionKey.thrift_spec), None, ), # 2
  )

  def __init__(self, lockKey=None, session=None,):
    self.lockKey = lockKey
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.lockKey = LockKey()
          self.lockKey.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.session = SessionKey()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acquireLock_args')
    if self.lockKey is not None:
      oprot.writeFieldBegin('lockKey', TType.STRUCT, 1)
      self.lockKey.write(oprot)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 2)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lockKey)
    value = (value * 31) ^ hash(self.session)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class acquireLock_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Response, Response.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Response()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('acquireLock_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class releaseLock_args:
  """
  Attributes:
   - lock
   - validation
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'lock', (Lock, Lock.thrift_spec), None, ), # 1
    (2, TType.I32, 'validation', None, None, ), # 2
    (3, TType.STRUCT, 'session', (SessionKey, SessionKey.thrift_spec), None, ), # 3
  )

  def __init__(self, lock=None, validation=None, session=None,):
    self.lock = lock
    self.validation = validation
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.lock = Lock()
          self.lock.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.validation = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.session = SessionKey()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('releaseLock_args')
    if self.lock is not None:
      oprot.writeFieldBegin('lock', TType.STRUCT, 1)
      self.lock.write(oprot)
      oprot.writeFieldEnd()
    if self.validation is not None:
      oprot.writeFieldBegin('validation', TType.I32, 2)
      oprot.writeI32(self.validation)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 3)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lock)
    value = (value * 31) ^ hash(self.validation)
    value = (value * 31) ^ hash(self.session)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class releaseLock_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Response, Response.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Response()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('releaseLock_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class replaceCronTemplate_args:
  """
  Attributes:
   - config
   - lock
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'config', (JobConfiguration, JobConfiguration.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'lock', (Lock, Lock.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'session', (SessionKey, SessionKey.thrift_spec), None, ), # 3
  )

  def __init__(self, config=None, lock=None, session=None,):
    self.config = config
    self.lock = lock
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.config = JobConfiguration()
          self.config.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.lock = Lock()
          self.lock.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.session = SessionKey()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('replaceCronTemplate_args')
    if self.config is not None:
      oprot.writeFieldBegin('config', TType.STRUCT, 1)
      self.config.write(oprot)
      oprot.writeFieldEnd()
    if self.lock is not None:
      oprot.writeFieldBegin('lock', TType.STRUCT, 2)
      self.lock.write(oprot)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 3)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.config)
    value = (value * 31) ^ hash(self.lock)
    value = (value * 31) ^ hash(self.session)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class replaceCronTemplate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Response, Response.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Response()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('replaceCronTemplate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startJobUpdate_args:
  """
  Attributes:
   - request: A description of how to change the job.
   - message: A user-specified message to include with the induced job update state change.
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (JobUpdateRequest, JobUpdateRequest.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'session', (SessionKey, SessionKey.thrift_spec), None, ), # 2
    (3, TType.STRING, 'message', None, None, ), # 3
  )

  def __init__(self, request=None, message=None, session=None,):
    self.request = request
    self.message = message
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = JobUpdateRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.session = SessionKey()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startJobUpdate_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 2)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 3)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    value = (value * 31) ^ hash(self.message)
    value = (value * 31) ^ hash(self.session)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startJobUpdate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Response, Response.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Response()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startJobUpdate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pauseJobUpdate_args:
  """
  Attributes:
   - key: The update to pause.
   - message: A user-specified message to include with the induced job update state change.
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'key', (JobUpdateKey, JobUpdateKey.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'session', (SessionKey, SessionKey.thrift_spec), None, ), # 2
    (3, TType.STRING, 'message', None, None, ), # 3
  )

  def __init__(self, key=None, message=None, session=None,):
    self.key = key
    self.message = message
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = JobUpdateKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.session = SessionKey()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pauseJobUpdate_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 2)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 3)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.message)
    value = (value * 31) ^ hash(self.session)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pauseJobUpdate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Response, Response.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Response()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pauseJobUpdate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resumeJobUpdate_args:
  """
  Attributes:
   - key: The update to resume.
   - message: A user-specified message to include with the induced job update state change.
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'key', (JobUpdateKey, JobUpdateKey.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'session', (SessionKey, SessionKey.thrift_spec), None, ), # 2
    (3, TType.STRING, 'message', None, None, ), # 3
  )

  def __init__(self, key=None, message=None, session=None,):
    self.key = key
    self.message = message
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = JobUpdateKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.session = SessionKey()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resumeJobUpdate_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 2)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 3)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.message)
    value = (value * 31) ^ hash(self.session)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resumeJobUpdate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Response, Response.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Response()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resumeJobUpdate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abortJobUpdate_args:
  """
  Attributes:
   - key: The update to abort.
   - message: A user-specified message to include with the induced job update state change.
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'key', (JobUpdateKey, JobUpdateKey.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'session', (SessionKey, SessionKey.thrift_spec), None, ), # 2
    (3, TType.STRING, 'message', None, None, ), # 3
  )

  def __init__(self, key=None, message=None, session=None,):
    self.key = key
    self.message = message
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = JobUpdateKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.session = SessionKey()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abortJobUpdate_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 2)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 3)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.message)
    value = (value * 31) ^ hash(self.session)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abortJobUpdate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Response, Response.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Response()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abortJobUpdate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pulseJobUpdate_args:
  """
  Attributes:
   - key
   - session
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'key', (JobUpdateKey, JobUpdateKey.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'session', (SessionKey, SessionKey.thrift_spec), None, ), # 2
  )

  def __init__(self, key=None, session=None,):
    self.key = key
    self.session = session

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = JobUpdateKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.session = SessionKey()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pulseJobUpdate_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.session is not None:
      oprot.writeFieldBegin('session', TType.STRUCT, 2)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.session)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pulseJobUpdate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Response, Response.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Response()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pulseJobUpdate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
