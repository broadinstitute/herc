#
# Autogenerated by Thrift Compiler (1.0.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ResponseCode:
  INVALID_REQUEST = 0
  OK = 1
  ERROR = 2
  WARNING = 3
  AUTH_FAILED = 4
  LOCK_ERROR = 5
  ERROR_TRANSIENT = 6

  _VALUES_TO_NAMES = {
    0: "INVALID_REQUEST",
    1: "OK",
    2: "ERROR",
    3: "WARNING",
    4: "AUTH_FAILED",
    5: "LOCK_ERROR",
    6: "ERROR_TRANSIENT",
  }

  _NAMES_TO_VALUES = {
    "INVALID_REQUEST": 0,
    "OK": 1,
    "ERROR": 2,
    "WARNING": 3,
    "AUTH_FAILED": 4,
    "LOCK_ERROR": 5,
    "ERROR_TRANSIENT": 6,
  }

class MaintenanceMode:
  NONE = 1
  SCHEDULED = 2
  DRAINING = 3
  DRAINED = 4

  _VALUES_TO_NAMES = {
    1: "NONE",
    2: "SCHEDULED",
    3: "DRAINING",
    4: "DRAINED",
  }

  _NAMES_TO_VALUES = {
    "NONE": 1,
    "SCHEDULED": 2,
    "DRAINING": 3,
    "DRAINED": 4,
  }

class LockValidation:
  """
  Defines the required lock validation level.
  """
  CHECKED = 0
  UNCHECKED = 1

  _VALUES_TO_NAMES = {
    0: "CHECKED",
    1: "UNCHECKED",
  }

  _NAMES_TO_VALUES = {
    "CHECKED": 0,
    "UNCHECKED": 1,
  }

class Mode:
  """
  The mode for a volume mount
  """
  RW = 1
  RO = 2

  _VALUES_TO_NAMES = {
    1: "RW",
    2: "RO",
  }

  _NAMES_TO_VALUES = {
    "RW": 1,
    "RO": 2,
  }

class CronCollisionPolicy:
  """
  Defines the policy for launching a new cron job when one is already running.
  """
  KILL_EXISTING = 0
  CANCEL_NEW = 1
  RUN_OVERLAP = 2

  _VALUES_TO_NAMES = {
    0: "KILL_EXISTING",
    1: "CANCEL_NEW",
    2: "RUN_OVERLAP",
  }

  _NAMES_TO_VALUES = {
    "KILL_EXISTING": 0,
    "CANCEL_NEW": 1,
    "RUN_OVERLAP": 2,
  }

class ScheduleStatus:
  """
  States that a task may be in.
  """
  INIT = 11
  THROTTLED = 16
  PENDING = 0
  ASSIGNED = 9
  STARTING = 1
  RUNNING = 2
  FINISHED = 3
  PREEMPTING = 13
  RESTARTING = 12
  DRAINING = 17
  FAILED = 4
  KILLED = 5
  KILLING = 6
  LOST = 7

  _VALUES_TO_NAMES = {
    11: "INIT",
    16: "THROTTLED",
    0: "PENDING",
    9: "ASSIGNED",
    1: "STARTING",
    2: "RUNNING",
    3: "FINISHED",
    13: "PREEMPTING",
    12: "RESTARTING",
    17: "DRAINING",
    4: "FAILED",
    5: "KILLED",
    6: "KILLING",
    7: "LOST",
  }

  _NAMES_TO_VALUES = {
    "INIT": 11,
    "THROTTLED": 16,
    "PENDING": 0,
    "ASSIGNED": 9,
    "STARTING": 1,
    "RUNNING": 2,
    "FINISHED": 3,
    "PREEMPTING": 13,
    "RESTARTING": 12,
    "DRAINING": 17,
    "FAILED": 4,
    "KILLED": 5,
    "KILLING": 6,
    "LOST": 7,
  }

class JobUpdateStatus:
  """
  States that a job update may be in.
  """
  ROLLING_FORWARD = 0
  ROLLING_BACK = 1
  ROLL_FORWARD_PAUSED = 2
  ROLL_BACK_PAUSED = 3
  ROLLED_FORWARD = 4
  ROLLED_BACK = 5
  ABORTED = 6
  ERROR = 7
  FAILED = 8
  ROLL_FORWARD_AWAITING_PULSE = 9
  ROLL_BACK_AWAITING_PULSE = 10

  _VALUES_TO_NAMES = {
    0: "ROLLING_FORWARD",
    1: "ROLLING_BACK",
    2: "ROLL_FORWARD_PAUSED",
    3: "ROLL_BACK_PAUSED",
    4: "ROLLED_FORWARD",
    5: "ROLLED_BACK",
    6: "ABORTED",
    7: "ERROR",
    8: "FAILED",
    9: "ROLL_FORWARD_AWAITING_PULSE",
    10: "ROLL_BACK_AWAITING_PULSE",
  }

  _NAMES_TO_VALUES = {
    "ROLLING_FORWARD": 0,
    "ROLLING_BACK": 1,
    "ROLL_FORWARD_PAUSED": 2,
    "ROLL_BACK_PAUSED": 3,
    "ROLLED_FORWARD": 4,
    "ROLLED_BACK": 5,
    "ABORTED": 6,
    "ERROR": 7,
    "FAILED": 8,
    "ROLL_FORWARD_AWAITING_PULSE": 9,
    "ROLL_BACK_AWAITING_PULSE": 10,
  }

class JobUpdateAction:
  """
  Job update actions that can be applied to job instances.
  """
  INSTANCE_UPDATED = 1
  INSTANCE_ROLLED_BACK = 2
  INSTANCE_UPDATING = 3
  INSTANCE_ROLLING_BACK = 4
  INSTANCE_UPDATE_FAILED = 5
  INSTANCE_ROLLBACK_FAILED = 6

  _VALUES_TO_NAMES = {
    1: "INSTANCE_UPDATED",
    2: "INSTANCE_ROLLED_BACK",
    3: "INSTANCE_UPDATING",
    4: "INSTANCE_ROLLING_BACK",
    5: "INSTANCE_UPDATE_FAILED",
    6: "INSTANCE_ROLLBACK_FAILED",
  }

  _NAMES_TO_VALUES = {
    "INSTANCE_UPDATED": 1,
    "INSTANCE_ROLLED_BACK": 2,
    "INSTANCE_UPDATING": 3,
    "INSTANCE_ROLLING_BACK": 4,
    "INSTANCE_UPDATE_FAILED": 5,
    "INSTANCE_ROLLBACK_FAILED": 6,
  }

class JobUpdatePulseStatus:
  """
  Status of the coordinated update. Intended as a response to pulseJobUpdate RPC.
  """
  OK = 1
  FINISHED = 2

  _VALUES_TO_NAMES = {
    1: "OK",
    2: "FINISHED",
  }

  _NAMES_TO_VALUES = {
    "OK": 1,
    "FINISHED": 2,
  }


class APIVersion:
  """
  Attributes:
   - major
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'major', None, None, ), # 1
  )

  def __init__(self, major=None,):
    self.major = major

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.major = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('APIVersion')
    if self.major is not None:
      oprot.writeFieldBegin('major', TType.I32, 1)
      oprot.writeI32(self.major)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.major is None:
      raise TProtocol.TProtocolException(message='Required field major is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.major)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Identity:
  """
  Attributes:
   - role
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role', None, None, ), # 1
    (2, TType.STRING, 'user', None, None, ), # 2
  )

  def __init__(self, role=None, user=None,):
    self.role = role
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Identity')
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRING, 1)
      oprot.writeString(self.role)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.role)
    value = (value * 31) ^ hash(self.user)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SessionKey:
  """
  Attributes:
   - mechanism: The name of the authentication mechanism, which instructs the server how to interpret the data
  field.
   - data: A blob of data that the server may use for authentication.
  """

  thrift_spec = (
    None, # 0
    None, # 1
    None, # 2
    None, # 3
    (4, TType.STRING, 'mechanism', None, None, ), # 4
    (5, TType.STRING, 'data', None, None, ), # 5
  )

  def __init__(self, mechanism=None, data=None,):
    self.mechanism = mechanism
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 4:
        if ftype == TType.STRING:
          self.mechanism = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.data = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SessionKey')
    if self.mechanism is not None:
      oprot.writeFieldBegin('mechanism', TType.STRING, 4)
      oprot.writeString(self.mechanism)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 5)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mechanism)
    value = (value * 31) ^ hash(self.data)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResourceAggregate:
  """
  Attributes:
   - numCpus: Number of CPU cores allotted.
   - ramMb: Megabytes of RAM allotted.
   - diskMb: Megabytes of disk space allotted.
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'numCpus', None, None, ), # 1
    (2, TType.I64, 'ramMb', None, None, ), # 2
    (3, TType.I64, 'diskMb', None, None, ), # 3
  )

  def __init__(self, numCpus=None, ramMb=None, diskMb=None,):
    self.numCpus = numCpus
    self.ramMb = ramMb
    self.diskMb = diskMb

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.numCpus = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.ramMb = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.diskMb = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResourceAggregate')
    if self.numCpus is not None:
      oprot.writeFieldBegin('numCpus', TType.DOUBLE, 1)
      oprot.writeDouble(self.numCpus)
      oprot.writeFieldEnd()
    if self.ramMb is not None:
      oprot.writeFieldBegin('ramMb', TType.I64, 2)
      oprot.writeI64(self.ramMb)
      oprot.writeFieldEnd()
    if self.diskMb is not None:
      oprot.writeFieldBegin('diskMb', TType.I64, 3)
      oprot.writeI64(self.diskMb)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.numCpus)
    value = (value * 31) ^ hash(self.ramMb)
    value = (value * 31) ^ hash(self.diskMb)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Attribute:
  """
  A single host attribute.

  Attributes:
   - name
   - values
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.SET, 'values', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, name=None, values=None,):
    self.name = name
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.values = set()
          (_etype3, _size0) = iprot.readSetBegin()
          for _i4 in range(_size0):
            _elem5 = iprot.readString()
            self.values.add(_elem5)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Attribute')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.values))
      for iter6 in self.values:
        oprot.writeString(iter6)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.values)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HostAttributes:
  """
  The attributes assigned to a host.

  Attributes:
   - host
   - attributes
   - mode
   - slaveId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'host', None, None, ), # 1
    (2, TType.SET, 'attributes', (TType.STRUCT,(Attribute, Attribute.thrift_spec)), None, ), # 2
    (3, TType.I32, 'mode', None, None, ), # 3
    (4, TType.STRING, 'slaveId', None, None, ), # 4
  )

  def __init__(self, host=None, attributes=None, mode=None, slaveId=None,):
    self.host = host
    self.attributes = attributes
    self.mode = mode
    self.slaveId = slaveId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.host = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.attributes = set()
          (_etype10, _size7) = iprot.readSetBegin()
          for _i11 in range(_size7):
            _elem12 = Attribute()
            _elem12.read(iprot)
            self.attributes.add(_elem12)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.mode = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.slaveId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HostAttributes')
    if self.host is not None:
      oprot.writeFieldBegin('host', TType.STRING, 1)
      oprot.writeString(self.host)
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.SET, 2)
      oprot.writeSetBegin(TType.STRUCT, len(self.attributes))
      for iter13 in self.attributes:
        iter13.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.mode is not None:
      oprot.writeFieldBegin('mode', TType.I32, 3)
      oprot.writeI32(self.mode)
      oprot.writeFieldEnd()
    if self.slaveId is not None:
      oprot.writeFieldBegin('slaveId', TType.STRING, 4)
      oprot.writeString(self.slaveId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.host)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.mode)
    value = (value * 31) ^ hash(self.slaveId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ValueConstraint:
  """
  A constraint that specifies an explicit set of values, at least one of which must be present
  on a host for a task to be scheduled there.

  Attributes:
   - negated: If true, treat this as a 'not' - to avoid specific values.
   - values
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'negated', None, None, ), # 1
    (2, TType.SET, 'values', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, negated=None, values=None,):
    self.negated = negated
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.negated = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.values = set()
          (_etype17, _size14) = iprot.readSetBegin()
          for _i18 in range(_size14):
            _elem19 = iprot.readString()
            self.values.add(_elem19)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ValueConstraint')
    if self.negated is not None:
      oprot.writeFieldBegin('negated', TType.BOOL, 1)
      oprot.writeBool(self.negated)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.values))
      for iter20 in self.values:
        oprot.writeString(iter20)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.negated)
    value = (value * 31) ^ hash(self.values)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LimitConstraint:
  """
  A constraint the specifies the maximum number of active tasks on a host with a matching
  attribute that may be scheduled simultaneously.

  Attributes:
   - limit
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'limit', None, None, ), # 1
  )

  def __init__(self, limit=None,):
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LimitConstraint')
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 1)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.limit)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TaskConstraint:
  """
  Types of constraints that may be applied to a task.

  Attributes:
   - value
   - limit
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'value', (ValueConstraint, ValueConstraint.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'limit', (LimitConstraint, LimitConstraint.thrift_spec), None, ), # 2
  )

  def __init__(self, value=None, limit=None,):
    self.value = value
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.value = ValueConstraint()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.limit = LimitConstraint()
          self.limit.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaskConstraint')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 1)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.STRUCT, 2)
      self.limit.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.limit)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Constraint:
  """
  A constraint that defines whether a task may be scheduled on a host.

  Attributes:
   - name: Mesos slave attribute that the constraint is matched against.
   - constraint
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRUCT, 'constraint', (TaskConstraint, TaskConstraint.thrift_spec), None, ), # 2
  )

  def __init__(self, name=None, constraint=None,):
    self.name = name
    self.constraint = constraint

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.constraint = TaskConstraint()
          self.constraint.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Constraint')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.constraint is not None:
      oprot.writeFieldBegin('constraint', TType.STRUCT, 2)
      self.constraint.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.constraint)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Package:
  """
  Attributes:
   - role
   - name
   - version
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.I32, 'version', None, None, ), # 3
  )

  def __init__(self, role=None, name=None, version=None,):
    self.role = role
    self.name = name
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.version = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Package')
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRING, 1)
      oprot.writeString(self.role)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 3)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.role)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.version)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Metadata:
  """
  Arbitrary key-value metadata to be included into TaskConfig.

  Attributes:
   - key
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
  )

  def __init__(self, key=None, value=None,):
    self.key = key
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Metadata')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobKey:
  """
  A unique identifier for a Job.

  Attributes:
   - role: User role (Unix service account), for example "mesos"
   - environment: Environment, for example "devel"
   - name: Name, for example "labrat"
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role', None, None, ), # 1
    (2, TType.STRING, 'environment', None, None, ), # 2
    (3, TType.STRING, 'name', None, None, ), # 3
  )

  def __init__(self, role=None, environment=None, name=None,):
    self.role = role
    self.environment = environment
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobKey')
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRING, 1)
      oprot.writeString(self.role)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 2)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 3)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.role)
    value = (value * 31) ^ hash(self.environment)
    value = (value * 31) ^ hash(self.name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LockKey:
  """
  A unique lock key.

  Attributes:
   - job
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'job', (JobKey, JobKey.thrift_spec), None, ), # 1
  )

  def __init__(self, job=None,):
    self.job = job

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.job = JobKey()
          self.job.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LockKey')
    if self.job is not None:
      oprot.writeFieldBegin('job', TType.STRUCT, 1)
      self.job.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.job)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Lock:
  """
  A generic lock struct to facilitate context specific resource/operation serialization.

  Attributes:
   - key: ID of the lock - unique per storage
   - token: UUID - facilitating soft lock authorization
   - user: Lock creator
   - timestampMs: Lock creation timestamp in milliseconds
   - message: Optional message to record with the lock
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'key', (LockKey, LockKey.thrift_spec), None, ), # 1
    (2, TType.STRING, 'token', None, None, ), # 2
    (3, TType.STRING, 'user', None, None, ), # 3
    (4, TType.I64, 'timestampMs', None, None, ), # 4
    (5, TType.STRING, 'message', None, None, ), # 5
  )

  def __init__(self, key=None, token=None, user=None, timestampMs=None, message=None,):
    self.key = key
    self.token = token
    self.user = user
    self.timestampMs = timestampMs
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = LockKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.token = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestampMs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Lock')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 2)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 3)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.timestampMs is not None:
      oprot.writeFieldBegin('timestampMs', TType.I64, 4)
      oprot.writeI64(self.timestampMs)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 5)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.timestampMs)
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InstanceKey:
  """
  A unique identifier for the active task within a job.

  Attributes:
   - jobKey: Key identifying the job.
   - instanceId: Unique instance ID for the active task in a job.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'jobKey', (JobKey, JobKey.thrift_spec), None, ), # 1
    (2, TType.I32, 'instanceId', None, None, ), # 2
  )

  def __init__(self, jobKey=None, instanceId=None,):
    self.jobKey = jobKey
    self.instanceId = instanceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.jobKey = JobKey()
          self.jobKey.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.instanceId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InstanceKey')
    if self.jobKey is not None:
      oprot.writeFieldBegin('jobKey', TType.STRUCT, 1)
      self.jobKey.write(oprot)
      oprot.writeFieldEnd()
    if self.instanceId is not None:
      oprot.writeFieldBegin('instanceId', TType.I32, 2)
      oprot.writeI32(self.instanceId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobKey)
    value = (value * 31) ^ hash(self.instanceId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExecutorConfig:
  """
  Attributes:
   - name: Name identifying the Executor.
   - data: Executor configuration data.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'data', None, None, ), # 2
  )

  def __init__(self, name=None, data=None,):
    self.name = name
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.data = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExecutorConfig')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 2)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.data)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Volume:
  """
  A volume mount point within a container

  Attributes:
   - containerPath: The path inside the container where the mount will be created.
   - hostPath: The path on the host that will serve as the source for the mount.
   - mode: The access mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'containerPath', None, None, ), # 1
    (2, TType.STRING, 'hostPath', None, None, ), # 2
    (3, TType.I32, 'mode', None, None, ), # 3
  )

  def __init__(self, containerPath=None, hostPath=None, mode=None,):
    self.containerPath = containerPath
    self.hostPath = hostPath
    self.mode = mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.containerPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.hostPath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.mode = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Volume')
    if self.containerPath is not None:
      oprot.writeFieldBegin('containerPath', TType.STRING, 1)
      oprot.writeString(self.containerPath)
      oprot.writeFieldEnd()
    if self.hostPath is not None:
      oprot.writeFieldBegin('hostPath', TType.STRING, 2)
      oprot.writeString(self.hostPath)
      oprot.writeFieldEnd()
    if self.mode is not None:
      oprot.writeFieldBegin('mode', TType.I32, 3)
      oprot.writeI32(self.mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.containerPath)
    value = (value * 31) ^ hash(self.hostPath)
    value = (value * 31) ^ hash(self.mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MesosContainer:
  """
  Describes a mesos container, this is the default
  """

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MesosContainer')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DockerContainer:
  """
  Describes a docker container

  Attributes:
   - image: The container image to be run
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'image', None, None, ), # 1
  )

  def __init__(self, image=None,):
    self.image = image

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.image = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DockerContainer')
    if self.image is not None:
      oprot.writeFieldBegin('image', TType.STRING, 1)
      oprot.writeString(self.image)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.image)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Container:
  """
  Describes a container to be used in a task

  Attributes:
   - mesos
   - docker
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'mesos', (MesosContainer, MesosContainer.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'docker', (DockerContainer, DockerContainer.thrift_spec), None, ), # 2
  )

  def __init__(self, mesos=None, docker=None,):
    self.mesos = mesos
    self.docker = docker

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.mesos = MesosContainer()
          self.mesos.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.docker = DockerContainer()
          self.docker.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Container')
    if self.mesos is not None:
      oprot.writeFieldBegin('mesos', TType.STRUCT, 1)
      self.mesos.write(oprot)
      oprot.writeFieldEnd()
    if self.docker is not None:
      oprot.writeFieldBegin('docker', TType.STRUCT, 2)
      self.docker.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mesos)
    value = (value * 31) ^ hash(self.docker)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TaskConfig:
  """
  Description of the tasks contained within a job.

  Attributes:
   - job: Job task belongs to.
   - owner: contains the role component of JobKey
   - environment: contains the environment component of JobKey
   - jobName: contains the name component of JobKey
   - isService
   - numCpus
   - ramMb
   - diskMb
   - priority
   - maxTaskFailures
   - production: Whether this is a production task, which can preempt.
   - constraints
   - requestedPorts: a list of named ports this task requests
   - container: the container the task should use to execute
   - taskLinks: Custom links to include when displaying this task on the scheduler dashboard. Keys are anchor
  text, values are URLs. Wildcards are supported for dynamic link crafting based on host, ports,
  instance, etc.
   - contactEmail
   - executorConfig: Executor configuration
   - metadata: Used to display additional details in the UI.
  """

  thrift_spec = (
    None, # 0
    None, # 1
    None, # 2
    (3, TType.STRING, 'jobName', None, None, ), # 3
    None, # 4
    None, # 5
    None, # 6
    (7, TType.BOOL, 'isService', None, None, ), # 7
    (8, TType.DOUBLE, 'numCpus', None, None, ), # 8
    (9, TType.I64, 'ramMb', None, None, ), # 9
    (10, TType.I64, 'diskMb', None, None, ), # 10
    (11, TType.I32, 'priority', None, None, ), # 11
    None, # 12
    (13, TType.I32, 'maxTaskFailures', None, None, ), # 13
    None, # 14
    None, # 15
    None, # 16
    (17, TType.STRUCT, 'owner', (Identity, Identity.thrift_spec), None, ), # 17
    (18, TType.BOOL, 'production', None, None, ), # 18
    None, # 19
    (20, TType.SET, 'constraints', (TType.STRUCT,(Constraint, Constraint.thrift_spec)), None, ), # 20
    (21, TType.SET, 'requestedPorts', (TType.STRING,None), None, ), # 21
    (22, TType.MAP, 'taskLinks', (TType.STRING,None,TType.STRING,None), None, ), # 22
    (23, TType.STRING, 'contactEmail', None, None, ), # 23
    None, # 24
    (25, TType.STRUCT, 'executorConfig', (ExecutorConfig, ExecutorConfig.thrift_spec), None, ), # 25
    (26, TType.STRING, 'environment', None, None, ), # 26
    (27, TType.SET, 'metadata', (TType.STRUCT,(Metadata, Metadata.thrift_spec)), None, ), # 27
    (28, TType.STRUCT, 'job', (JobKey, JobKey.thrift_spec), None, ), # 28
    (29, TType.STRUCT, 'container', (Container, Container.thrift_spec), Container(**{
      "mesos" : MesosContainer(**{
      }),
    }), ), # 29
  )

  def __init__(self, job=None, owner=None, environment=None, jobName=None, isService=None, numCpus=None, ramMb=None, diskMb=None, priority=None, maxTaskFailures=None, production=None, constraints=None, requestedPorts=None, container=thrift_spec[29][4], taskLinks=None, contactEmail=None, executorConfig=None, metadata=None,):
    self.job = job
    self.owner = owner
    self.environment = environment
    self.jobName = jobName
    self.isService = isService
    self.numCpus = numCpus
    self.ramMb = ramMb
    self.diskMb = diskMb
    self.priority = priority
    self.maxTaskFailures = maxTaskFailures
    self.production = production
    self.constraints = constraints
    self.requestedPorts = requestedPorts
    if container is self.thrift_spec[29][4]:
      container = Container(**{
      "mesos" : MesosContainer(**{
      }),
    })
    self.container = container
    self.taskLinks = taskLinks
    self.contactEmail = contactEmail
    self.executorConfig = executorConfig
    self.metadata = metadata

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 28:
        if ftype == TType.STRUCT:
          self.job = JobKey()
          self.job.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRUCT:
          self.owner = Identity()
          self.owner.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 26:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.jobName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.isService = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.DOUBLE:
          self.numCpus = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.ramMb = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.diskMb = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.priority = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.maxTaskFailures = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.BOOL:
          self.production = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.SET:
          self.constraints = set()
          (_etype24, _size21) = iprot.readSetBegin()
          for _i25 in range(_size21):
            _elem26 = Constraint()
            _elem26.read(iprot)
            self.constraints.add(_elem26)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.SET:
          self.requestedPorts = set()
          (_etype30, _size27) = iprot.readSetBegin()
          for _i31 in range(_size27):
            _elem32 = iprot.readString()
            self.requestedPorts.add(_elem32)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 29:
        if ftype == TType.STRUCT:
          self.container = Container()
          self.container.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.MAP:
          self.taskLinks = {}
          (_ktype34, _vtype35, _size33 ) = iprot.readMapBegin()
          for _i37 in range(_size33):
            _key38 = iprot.readString()
            _val39 = iprot.readString()
            self.taskLinks[_key38] = _val39
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRING:
          self.contactEmail = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.STRUCT:
          self.executorConfig = ExecutorConfig()
          self.executorConfig.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 27:
        if ftype == TType.SET:
          self.metadata = set()
          (_etype43, _size40) = iprot.readSetBegin()
          for _i44 in range(_size40):
            _elem45 = Metadata()
            _elem45.read(iprot)
            self.metadata.add(_elem45)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaskConfig')
    if self.jobName is not None:
      oprot.writeFieldBegin('jobName', TType.STRING, 3)
      oprot.writeString(self.jobName)
      oprot.writeFieldEnd()
    if self.isService is not None:
      oprot.writeFieldBegin('isService', TType.BOOL, 7)
      oprot.writeBool(self.isService)
      oprot.writeFieldEnd()
    if self.numCpus is not None:
      oprot.writeFieldBegin('numCpus', TType.DOUBLE, 8)
      oprot.writeDouble(self.numCpus)
      oprot.writeFieldEnd()
    if self.ramMb is not None:
      oprot.writeFieldBegin('ramMb', TType.I64, 9)
      oprot.writeI64(self.ramMb)
      oprot.writeFieldEnd()
    if self.diskMb is not None:
      oprot.writeFieldBegin('diskMb', TType.I64, 10)
      oprot.writeI64(self.diskMb)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 11)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.maxTaskFailures is not None:
      oprot.writeFieldBegin('maxTaskFailures', TType.I32, 13)
      oprot.writeI32(self.maxTaskFailures)
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRUCT, 17)
      self.owner.write(oprot)
      oprot.writeFieldEnd()
    if self.production is not None:
      oprot.writeFieldBegin('production', TType.BOOL, 18)
      oprot.writeBool(self.production)
      oprot.writeFieldEnd()
    if self.constraints is not None:
      oprot.writeFieldBegin('constraints', TType.SET, 20)
      oprot.writeSetBegin(TType.STRUCT, len(self.constraints))
      for iter46 in self.constraints:
        iter46.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.requestedPorts is not None:
      oprot.writeFieldBegin('requestedPorts', TType.SET, 21)
      oprot.writeSetBegin(TType.STRING, len(self.requestedPorts))
      for iter47 in self.requestedPorts:
        oprot.writeString(iter47)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.taskLinks is not None:
      oprot.writeFieldBegin('taskLinks', TType.MAP, 22)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.taskLinks))
      for kiter48,viter49 in self.taskLinks.items():
        oprot.writeString(kiter48)
        oprot.writeString(viter49)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.contactEmail is not None:
      oprot.writeFieldBegin('contactEmail', TType.STRING, 23)
      oprot.writeString(self.contactEmail)
      oprot.writeFieldEnd()
    if self.executorConfig is not None:
      oprot.writeFieldBegin('executorConfig', TType.STRUCT, 25)
      self.executorConfig.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 26)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.SET, 27)
      oprot.writeSetBegin(TType.STRUCT, len(self.metadata))
      for iter50 in self.metadata:
        iter50.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.job is not None:
      oprot.writeFieldBegin('job', TType.STRUCT, 28)
      self.job.write(oprot)
      oprot.writeFieldEnd()
    if self.container is not None:
      oprot.writeFieldBegin('container', TType.STRUCT, 29)
      self.container.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.job)
    value = (value * 31) ^ hash(self.owner)
    value = (value * 31) ^ hash(self.environment)
    value = (value * 31) ^ hash(self.jobName)
    value = (value * 31) ^ hash(self.isService)
    value = (value * 31) ^ hash(self.numCpus)
    value = (value * 31) ^ hash(self.ramMb)
    value = (value * 31) ^ hash(self.diskMb)
    value = (value * 31) ^ hash(self.priority)
    value = (value * 31) ^ hash(self.maxTaskFailures)
    value = (value * 31) ^ hash(self.production)
    value = (value * 31) ^ hash(self.constraints)
    value = (value * 31) ^ hash(self.requestedPorts)
    value = (value * 31) ^ hash(self.container)
    value = (value * 31) ^ hash(self.taskLinks)
    value = (value * 31) ^ hash(self.contactEmail)
    value = (value * 31) ^ hash(self.executorConfig)
    value = (value * 31) ^ hash(self.metadata)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobConfiguration:
  """
  Description of an Aurora job. One task will be scheduled for each instance within the job.

  Attributes:
   - key: Key for this job. If not specified name, owner.role, and a reasonable default environment are
  used to construct it server-side.
   - owner: Owner of this job.
   - cronSchedule: If present, the job will be handled as a cron job with this crontab-syntax schedule.
   - cronCollisionPolicy: Collision policy to use when handling overlapping cron runs.  Default is KILL_EXISTING.
   - taskConfig: Task configuration for this job.
   - instanceCount: The number of instances in the job. Generated instance IDs for tasks will be in the range
  [0, instances).
  """

  thrift_spec = (
    None, # 0
    None, # 1
    None, # 2
    None, # 3
    (4, TType.STRING, 'cronSchedule', None, None, ), # 4
    (5, TType.I32, 'cronCollisionPolicy', None, None, ), # 5
    (6, TType.STRUCT, 'taskConfig', (TaskConfig, TaskConfig.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'owner', (Identity, Identity.thrift_spec), None, ), # 7
    (8, TType.I32, 'instanceCount', None, None, ), # 8
    (9, TType.STRUCT, 'key', (JobKey, JobKey.thrift_spec), None, ), # 9
  )

  def __init__(self, key=None, owner=None, cronSchedule=None, cronCollisionPolicy=None, taskConfig=None, instanceCount=None,):
    self.key = key
    self.owner = owner
    self.cronSchedule = cronSchedule
    self.cronCollisionPolicy = cronCollisionPolicy
    self.taskConfig = taskConfig
    self.instanceCount = instanceCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 9:
        if ftype == TType.STRUCT:
          self.key = JobKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.owner = Identity()
          self.owner.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.cronSchedule = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.cronCollisionPolicy = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.taskConfig = TaskConfig()
          self.taskConfig.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.instanceCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobConfiguration')
    if self.cronSchedule is not None:
      oprot.writeFieldBegin('cronSchedule', TType.STRING, 4)
      oprot.writeString(self.cronSchedule)
      oprot.writeFieldEnd()
    if self.cronCollisionPolicy is not None:
      oprot.writeFieldBegin('cronCollisionPolicy', TType.I32, 5)
      oprot.writeI32(self.cronCollisionPolicy)
      oprot.writeFieldEnd()
    if self.taskConfig is not None:
      oprot.writeFieldBegin('taskConfig', TType.STRUCT, 6)
      self.taskConfig.write(oprot)
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRUCT, 7)
      self.owner.write(oprot)
      oprot.writeFieldEnd()
    if self.instanceCount is not None:
      oprot.writeFieldBegin('instanceCount', TType.I32, 8)
      oprot.writeI32(self.instanceCount)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 9)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.owner)
    value = (value * 31) ^ hash(self.cronSchedule)
    value = (value * 31) ^ hash(self.cronCollisionPolicy)
    value = (value * 31) ^ hash(self.taskConfig)
    value = (value * 31) ^ hash(self.instanceCount)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobStats:
  """
  Attributes:
   - activeTaskCount: Number of tasks in active state for this job.
   - finishedTaskCount: Number of tasks in finished state for this job.
   - failedTaskCount: Number of failed tasks for this job.
   - pendingTaskCount: Number of tasks in pending state for this job.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'activeTaskCount', None, None, ), # 1
    (2, TType.I32, 'finishedTaskCount', None, None, ), # 2
    (3, TType.I32, 'failedTaskCount', None, None, ), # 3
    (4, TType.I32, 'pendingTaskCount', None, None, ), # 4
  )

  def __init__(self, activeTaskCount=None, finishedTaskCount=None, failedTaskCount=None, pendingTaskCount=None,):
    self.activeTaskCount = activeTaskCount
    self.finishedTaskCount = finishedTaskCount
    self.failedTaskCount = failedTaskCount
    self.pendingTaskCount = pendingTaskCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.activeTaskCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.finishedTaskCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.failedTaskCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.pendingTaskCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobStats')
    if self.activeTaskCount is not None:
      oprot.writeFieldBegin('activeTaskCount', TType.I32, 1)
      oprot.writeI32(self.activeTaskCount)
      oprot.writeFieldEnd()
    if self.finishedTaskCount is not None:
      oprot.writeFieldBegin('finishedTaskCount', TType.I32, 2)
      oprot.writeI32(self.finishedTaskCount)
      oprot.writeFieldEnd()
    if self.failedTaskCount is not None:
      oprot.writeFieldBegin('failedTaskCount', TType.I32, 3)
      oprot.writeI32(self.failedTaskCount)
      oprot.writeFieldEnd()
    if self.pendingTaskCount is not None:
      oprot.writeFieldBegin('pendingTaskCount', TType.I32, 4)
      oprot.writeI32(self.pendingTaskCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.activeTaskCount)
    value = (value * 31) ^ hash(self.finishedTaskCount)
    value = (value * 31) ^ hash(self.failedTaskCount)
    value = (value * 31) ^ hash(self.pendingTaskCount)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobSummary:
  """
  Attributes:
   - job
   - stats
   - nextCronRunMs: Timestamp of next cron run in ms since epoch, for a cron job
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'job', (JobConfiguration, JobConfiguration.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'stats', (JobStats, JobStats.thrift_spec), None, ), # 2
    (3, TType.I64, 'nextCronRunMs', None, None, ), # 3
  )

  def __init__(self, job=None, stats=None, nextCronRunMs=None,):
    self.job = job
    self.stats = stats
    self.nextCronRunMs = nextCronRunMs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.job = JobConfiguration()
          self.job.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.stats = JobStats()
          self.stats.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.nextCronRunMs = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobSummary')
    if self.job is not None:
      oprot.writeFieldBegin('job', TType.STRUCT, 1)
      self.job.write(oprot)
      oprot.writeFieldEnd()
    if self.stats is not None:
      oprot.writeFieldBegin('stats', TType.STRUCT, 2)
      self.stats.write(oprot)
      oprot.writeFieldEnd()
    if self.nextCronRunMs is not None:
      oprot.writeFieldBegin('nextCronRunMs', TType.I64, 3)
      oprot.writeI64(self.nextCronRunMs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.job)
    value = (value * 31) ^ hash(self.stats)
    value = (value * 31) ^ hash(self.nextCronRunMs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddInstancesConfig:
  """
  A request to add the following instances to an existing job. Used by addInstances.

  Attributes:
   - key
   - taskConfig
   - instanceIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'key', (JobKey, JobKey.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'taskConfig', (TaskConfig, TaskConfig.thrift_spec), None, ), # 2
    (3, TType.SET, 'instanceIds', (TType.I32,None), None, ), # 3
  )

  def __init__(self, key=None, taskConfig=None, instanceIds=None,):
    self.key = key
    self.taskConfig = taskConfig
    self.instanceIds = instanceIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = JobKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.taskConfig = TaskConfig()
          self.taskConfig.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.instanceIds = set()
          (_etype54, _size51) = iprot.readSetBegin()
          for _i55 in range(_size51):
            _elem56 = iprot.readI32()
            self.instanceIds.add(_elem56)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddInstancesConfig')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.taskConfig is not None:
      oprot.writeFieldBegin('taskConfig', TType.STRUCT, 2)
      self.taskConfig.write(oprot)
      oprot.writeFieldEnd()
    if self.instanceIds is not None:
      oprot.writeFieldBegin('instanceIds', TType.SET, 3)
      oprot.writeSetBegin(TType.I32, len(self.instanceIds))
      for iter57 in self.instanceIds:
        oprot.writeI32(iter57)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.taskConfig)
    value = (value * 31) ^ hash(self.instanceIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Range:
  """
  Closed range of integers.

  Attributes:
   - first
   - last
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'first', None, None, ), # 1
    (2, TType.I32, 'last', None, None, ), # 2
  )

  def __init__(self, first=None, last=None,):
    self.first = first
    self.last = last

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.first = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.last = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Range')
    if self.first is not None:
      oprot.writeFieldBegin('first', TType.I32, 1)
      oprot.writeI32(self.first)
      oprot.writeFieldEnd()
    if self.last is not None:
      oprot.writeFieldBegin('last', TType.I32, 2)
      oprot.writeI32(self.last)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.first)
    value = (value * 31) ^ hash(self.last)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConfigGroup:
  """
  Attributes:
   - config
   - instanceIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'config', (TaskConfig, TaskConfig.thrift_spec), None, ), # 1
    (2, TType.SET, 'instanceIds', (TType.I32,None), None, ), # 2
  )

  def __init__(self, config=None, instanceIds=None,):
    self.config = config
    self.instanceIds = instanceIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.config = TaskConfig()
          self.config.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.instanceIds = set()
          (_etype61, _size58) = iprot.readSetBegin()
          for _i62 in range(_size58):
            _elem63 = iprot.readI32()
            self.instanceIds.add(_elem63)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfigGroup')
    if self.config is not None:
      oprot.writeFieldBegin('config', TType.STRUCT, 1)
      self.config.write(oprot)
      oprot.writeFieldEnd()
    if self.instanceIds is not None:
      oprot.writeFieldBegin('instanceIds', TType.SET, 2)
      oprot.writeSetBegin(TType.I32, len(self.instanceIds))
      for iter64 in self.instanceIds:
        oprot.writeI32(iter64)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.config)
    value = (value * 31) ^ hash(self.instanceIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConfigSummary:
  """
  Attributes:
   - key
   - groups
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'key', (JobKey, JobKey.thrift_spec), None, ), # 1
    (2, TType.SET, 'groups', (TType.STRUCT,(ConfigGroup, ConfigGroup.thrift_spec)), None, ), # 2
  )

  def __init__(self, key=None, groups=None,):
    self.key = key
    self.groups = groups

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = JobKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.groups = set()
          (_etype68, _size65) = iprot.readSetBegin()
          for _i69 in range(_size65):
            _elem70 = ConfigGroup()
            _elem70.read(iprot)
            self.groups.add(_elem70)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfigSummary')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.groups is not None:
      oprot.writeFieldBegin('groups', TType.SET, 2)
      oprot.writeSetBegin(TType.STRUCT, len(self.groups))
      for iter71 in self.groups:
        iter71.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.groups)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PopulateJobResult:
  """
  Attributes:
   - populatedDEPRECATED
   - taskConfig
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'populatedDEPRECATED', (TType.STRUCT,(TaskConfig, TaskConfig.thrift_spec)), None, ), # 1
    (2, TType.STRUCT, 'taskConfig', (TaskConfig, TaskConfig.thrift_spec), None, ), # 2
  )

  def __init__(self, populatedDEPRECATED=None, taskConfig=None,):
    self.populatedDEPRECATED = populatedDEPRECATED
    self.taskConfig = taskConfig

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.populatedDEPRECATED = set()
          (_etype75, _size72) = iprot.readSetBegin()
          for _i76 in range(_size72):
            _elem77 = TaskConfig()
            _elem77.read(iprot)
            self.populatedDEPRECATED.add(_elem77)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.taskConfig = TaskConfig()
          self.taskConfig.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PopulateJobResult')
    if self.populatedDEPRECATED is not None:
      oprot.writeFieldBegin('populatedDEPRECATED', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.populatedDEPRECATED))
      for iter78 in self.populatedDEPRECATED:
        iter78.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.taskConfig is not None:
      oprot.writeFieldBegin('taskConfig', TType.STRUCT, 2)
      self.taskConfig.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.populatedDEPRECATED)
    value = (value * 31) ^ hash(self.taskConfig)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetQuotaResult:
  """
  Attributes:
   - quota: Total allocated resource quota.
   - prodConsumption: Resources consumed by production jobs.
   - nonProdConsumption: Resources consumed by non-production jobs.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'quota', (ResourceAggregate, ResourceAggregate.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'prodConsumption', (ResourceAggregate, ResourceAggregate.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nonProdConsumption', (ResourceAggregate, ResourceAggregate.thrift_spec), None, ), # 3
  )

  def __init__(self, quota=None, prodConsumption=None, nonProdConsumption=None,):
    self.quota = quota
    self.prodConsumption = prodConsumption
    self.nonProdConsumption = nonProdConsumption

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.quota = ResourceAggregate()
          self.quota.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.prodConsumption = ResourceAggregate()
          self.prodConsumption.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nonProdConsumption = ResourceAggregate()
          self.nonProdConsumption.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetQuotaResult')
    if self.quota is not None:
      oprot.writeFieldBegin('quota', TType.STRUCT, 1)
      self.quota.write(oprot)
      oprot.writeFieldEnd()
    if self.prodConsumption is not None:
      oprot.writeFieldBegin('prodConsumption', TType.STRUCT, 2)
      self.prodConsumption.write(oprot)
      oprot.writeFieldEnd()
    if self.nonProdConsumption is not None:
      oprot.writeFieldBegin('nonProdConsumption', TType.STRUCT, 3)
      self.nonProdConsumption.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.quota)
    value = (value * 31) ^ hash(self.prodConsumption)
    value = (value * 31) ^ hash(self.nonProdConsumption)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AcquireLockResult:
  """
  Wraps return results for the acquireLock API.

  Attributes:
   - lock: Acquired Lock instance.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'lock', (Lock, Lock.thrift_spec), None, ), # 1
  )

  def __init__(self, lock=None,):
    self.lock = lock

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.lock = Lock()
          self.lock.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AcquireLockResult')
    if self.lock is not None:
      oprot.writeFieldBegin('lock', TType.STRUCT, 1)
      self.lock.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lock)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TaskEvent:
  """
  Event marking a state transition within a task's lifecycle.

  Attributes:
   - timestamp: Epoch timestamp in milliseconds.
   - status: New status of the task.
   - message: Audit message that explains why a transition occurred.
   - scheduler: Hostname of the scheduler machine that performed the event.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'timestamp', None, None, ), # 1
    (2, TType.I32, 'status', None, None, ), # 2
    (3, TType.STRING, 'message', None, None, ), # 3
    (4, TType.STRING, 'scheduler', None, None, ), # 4
  )

  def __init__(self, timestamp=None, status=None, message=None, scheduler=None,):
    self.timestamp = timestamp
    self.status = status
    self.message = message
    self.scheduler = scheduler

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.scheduler = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaskEvent')
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 1)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 2)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 3)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    if self.scheduler is not None:
      oprot.writeFieldBegin('scheduler', TType.STRING, 4)
      oprot.writeString(self.scheduler)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.message)
    value = (value * 31) ^ hash(self.scheduler)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AssignedTask:
  """
  A task assignment that is provided to an executor.

  Attributes:
   - taskId: The mesos task ID for this task.  Guaranteed to be globally unique
   - slaveId: The mesos slave ID that this task has been assigned to.
  This will not be populated for a PENDING task.
   - slaveHost: The name of the machine that this task has been assigned to.
  This will not be populated for a PENDING task.
   - task: Information about how to run this task.
   - assignedPorts: Ports reserved on the machine while this task is running.
   - instanceId: The instance ID assigned to this task. Instance IDs must be unique and contiguous within a
  job, and will be in the range [0, N-1] (inclusive) for a job that has N instances.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'taskId', None, None, ), # 1
    (2, TType.STRING, 'slaveId', None, None, ), # 2
    (3, TType.STRING, 'slaveHost', None, None, ), # 3
    (4, TType.STRUCT, 'task', (TaskConfig, TaskConfig.thrift_spec), None, ), # 4
    (5, TType.MAP, 'assignedPorts', (TType.STRING,None,TType.I32,None), None, ), # 5
    (6, TType.I32, 'instanceId', None, None, ), # 6
  )

  def __init__(self, taskId=None, slaveId=None, slaveHost=None, task=None, assignedPorts=None, instanceId=None,):
    self.taskId = taskId
    self.slaveId = slaveId
    self.slaveHost = slaveHost
    self.task = task
    self.assignedPorts = assignedPorts
    self.instanceId = instanceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.taskId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.slaveId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.slaveHost = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.task = TaskConfig()
          self.task.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.assignedPorts = {}
          (_ktype80, _vtype81, _size79 ) = iprot.readMapBegin()
          for _i83 in range(_size79):
            _key84 = iprot.readString()
            _val85 = iprot.readI32()
            self.assignedPorts[_key84] = _val85
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.instanceId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AssignedTask')
    if self.taskId is not None:
      oprot.writeFieldBegin('taskId', TType.STRING, 1)
      oprot.writeString(self.taskId)
      oprot.writeFieldEnd()
    if self.slaveId is not None:
      oprot.writeFieldBegin('slaveId', TType.STRING, 2)
      oprot.writeString(self.slaveId)
      oprot.writeFieldEnd()
    if self.slaveHost is not None:
      oprot.writeFieldBegin('slaveHost', TType.STRING, 3)
      oprot.writeString(self.slaveHost)
      oprot.writeFieldEnd()
    if self.task is not None:
      oprot.writeFieldBegin('task', TType.STRUCT, 4)
      self.task.write(oprot)
      oprot.writeFieldEnd()
    if self.assignedPorts is not None:
      oprot.writeFieldBegin('assignedPorts', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.assignedPorts))
      for kiter86,viter87 in self.assignedPorts.items():
        oprot.writeString(kiter86)
        oprot.writeI32(viter87)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.instanceId is not None:
      oprot.writeFieldBegin('instanceId', TType.I32, 6)
      oprot.writeI32(self.instanceId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.taskId)
    value = (value * 31) ^ hash(self.slaveId)
    value = (value * 31) ^ hash(self.slaveHost)
    value = (value * 31) ^ hash(self.task)
    value = (value * 31) ^ hash(self.assignedPorts)
    value = (value * 31) ^ hash(self.instanceId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScheduledTask:
  """
  A task that has been scheduled.

  Attributes:
   - assignedTask: The task that was scheduled.
   - status: The current status of this task.
   - failureCount: The number of failures that this task has accumulated over the multi-generational history of
  this task.
   - taskEvents: State change history for this task.
   - ancestorId: The task ID of the previous generation of this task.  When a task is automatically rescheduled,
  a copy of the task is created and ancestor ID of the previous task's task ID.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'assignedTask', (AssignedTask, AssignedTask.thrift_spec), None, ), # 1
    (2, TType.I32, 'status', None, None, ), # 2
    (3, TType.I32, 'failureCount', None, None, ), # 3
    (4, TType.LIST, 'taskEvents', (TType.STRUCT,(TaskEvent, TaskEvent.thrift_spec)), None, ), # 4
    (5, TType.STRING, 'ancestorId', None, None, ), # 5
  )

  def __init__(self, assignedTask=None, status=None, failureCount=None, taskEvents=None, ancestorId=None,):
    self.assignedTask = assignedTask
    self.status = status
    self.failureCount = failureCount
    self.taskEvents = taskEvents
    self.ancestorId = ancestorId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assignedTask = AssignedTask()
          self.assignedTask.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.failureCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.taskEvents = []
          (_etype91, _size88) = iprot.readListBegin()
          for _i92 in range(_size88):
            _elem93 = TaskEvent()
            _elem93.read(iprot)
            self.taskEvents.append(_elem93)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.ancestorId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScheduledTask')
    if self.assignedTask is not None:
      oprot.writeFieldBegin('assignedTask', TType.STRUCT, 1)
      self.assignedTask.write(oprot)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 2)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.failureCount is not None:
      oprot.writeFieldBegin('failureCount', TType.I32, 3)
      oprot.writeI32(self.failureCount)
      oprot.writeFieldEnd()
    if self.taskEvents is not None:
      oprot.writeFieldBegin('taskEvents', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.taskEvents))
      for iter94 in self.taskEvents:
        iter94.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ancestorId is not None:
      oprot.writeFieldBegin('ancestorId', TType.STRING, 5)
      oprot.writeString(self.ancestorId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.assignedTask)
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.failureCount)
    value = (value * 31) ^ hash(self.taskEvents)
    value = (value * 31) ^ hash(self.ancestorId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScheduleStatusResult:
  """
  Attributes:
   - tasks
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tasks', (TType.STRUCT,(ScheduledTask, ScheduledTask.thrift_spec)), None, ), # 1
  )

  def __init__(self, tasks=None,):
    self.tasks = tasks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tasks = []
          (_etype98, _size95) = iprot.readListBegin()
          for _i99 in range(_size95):
            _elem100 = ScheduledTask()
            _elem100.read(iprot)
            self.tasks.append(_elem100)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScheduleStatusResult')
    if self.tasks is not None:
      oprot.writeFieldBegin('tasks', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.tasks))
      for iter101 in self.tasks:
        iter101.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tasks)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetJobsResult:
  """
  Attributes:
   - configs
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'configs', (TType.STRUCT,(JobConfiguration, JobConfiguration.thrift_spec)), None, ), # 1
  )

  def __init__(self, configs=None,):
    self.configs = configs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.configs = set()
          (_etype105, _size102) = iprot.readSetBegin()
          for _i106 in range(_size102):
            _elem107 = JobConfiguration()
            _elem107.read(iprot)
            self.configs.add(_elem107)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetJobsResult')
    if self.configs is not None:
      oprot.writeFieldBegin('configs', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.configs))
      for iter108 in self.configs:
        iter108.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.configs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TaskQuery:
  """
  Contains a set of restrictions on matching tasks where all restrictions must be met
  (terms are AND'ed together).

  Attributes:
   - owner
   - role
   - environment
   - jobName
   - taskIds
   - statuses
   - instanceIds
   - slaveHosts
   - jobKeys
   - offset
   - limit
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'jobName', None, None, ), # 2
    None, # 3
    (4, TType.SET, 'taskIds', (TType.STRING,None), None, ), # 4
    (5, TType.SET, 'statuses', (TType.I32,None), None, ), # 5
    None, # 6
    (7, TType.SET, 'instanceIds', (TType.I32,None), None, ), # 7
    (8, TType.STRUCT, 'owner', (Identity, Identity.thrift_spec), None, ), # 8
    (9, TType.STRING, 'environment', None, None, ), # 9
    (10, TType.SET, 'slaveHosts', (TType.STRING,None), None, ), # 10
    (11, TType.SET, 'jobKeys', (TType.STRUCT,(JobKey, JobKey.thrift_spec)), None, ), # 11
    (12, TType.I32, 'offset', None, None, ), # 12
    (13, TType.I32, 'limit', None, None, ), # 13
    (14, TType.STRING, 'role', None, None, ), # 14
  )

  def __init__(self, owner=None, role=None, environment=None, jobName=None, taskIds=None, statuses=None, instanceIds=None, slaveHosts=None, jobKeys=None, offset=None, limit=None,):
    self.owner = owner
    self.role = role
    self.environment = environment
    self.jobName = jobName
    self.taskIds = taskIds
    self.statuses = statuses
    self.instanceIds = instanceIds
    self.slaveHosts = slaveHosts
    self.jobKeys = jobKeys
    self.offset = offset
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 8:
        if ftype == TType.STRUCT:
          self.owner = Identity()
          self.owner.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.role = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.taskIds = set()
          (_etype112, _size109) = iprot.readSetBegin()
          for _i113 in range(_size109):
            _elem114 = iprot.readString()
            self.taskIds.add(_elem114)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.SET:
          self.statuses = set()
          (_etype118, _size115) = iprot.readSetBegin()
          for _i119 in range(_size115):
            _elem120 = iprot.readI32()
            self.statuses.add(_elem120)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.instanceIds = set()
          (_etype124, _size121) = iprot.readSetBegin()
          for _i125 in range(_size121):
            _elem126 = iprot.readI32()
            self.instanceIds.add(_elem126)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.SET:
          self.slaveHosts = set()
          (_etype130, _size127) = iprot.readSetBegin()
          for _i131 in range(_size127):
            _elem132 = iprot.readString()
            self.slaveHosts.add(_elem132)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.SET:
          self.jobKeys = set()
          (_etype136, _size133) = iprot.readSetBegin()
          for _i137 in range(_size133):
            _elem138 = JobKey()
            _elem138.read(iprot)
            self.jobKeys.add(_elem138)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaskQuery')
    if self.jobName is not None:
      oprot.writeFieldBegin('jobName', TType.STRING, 2)
      oprot.writeString(self.jobName)
      oprot.writeFieldEnd()
    if self.taskIds is not None:
      oprot.writeFieldBegin('taskIds', TType.SET, 4)
      oprot.writeSetBegin(TType.STRING, len(self.taskIds))
      for iter139 in self.taskIds:
        oprot.writeString(iter139)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.statuses is not None:
      oprot.writeFieldBegin('statuses', TType.SET, 5)
      oprot.writeSetBegin(TType.I32, len(self.statuses))
      for iter140 in self.statuses:
        oprot.writeI32(iter140)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.instanceIds is not None:
      oprot.writeFieldBegin('instanceIds', TType.SET, 7)
      oprot.writeSetBegin(TType.I32, len(self.instanceIds))
      for iter141 in self.instanceIds:
        oprot.writeI32(iter141)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRUCT, 8)
      self.owner.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 9)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    if self.slaveHosts is not None:
      oprot.writeFieldBegin('slaveHosts', TType.SET, 10)
      oprot.writeSetBegin(TType.STRING, len(self.slaveHosts))
      for iter142 in self.slaveHosts:
        oprot.writeString(iter142)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.jobKeys is not None:
      oprot.writeFieldBegin('jobKeys', TType.SET, 11)
      oprot.writeSetBegin(TType.STRUCT, len(self.jobKeys))
      for iter143 in self.jobKeys:
        iter143.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 12)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 13)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRING, 14)
      oprot.writeString(self.role)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.owner)
    value = (value * 31) ^ hash(self.role)
    value = (value * 31) ^ hash(self.environment)
    value = (value * 31) ^ hash(self.jobName)
    value = (value * 31) ^ hash(self.taskIds)
    value = (value * 31) ^ hash(self.statuses)
    value = (value * 31) ^ hash(self.instanceIds)
    value = (value * 31) ^ hash(self.slaveHosts)
    value = (value * 31) ^ hash(self.jobKeys)
    value = (value * 31) ^ hash(self.offset)
    value = (value * 31) ^ hash(self.limit)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HostStatus:
  """
  Attributes:
   - host
   - mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'host', None, None, ), # 1
    (2, TType.I32, 'mode', None, None, ), # 2
  )

  def __init__(self, host=None, mode=None,):
    self.host = host
    self.mode = mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.host = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.mode = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HostStatus')
    if self.host is not None:
      oprot.writeFieldBegin('host', TType.STRING, 1)
      oprot.writeString(self.host)
      oprot.writeFieldEnd()
    if self.mode is not None:
      oprot.writeFieldBegin('mode', TType.I32, 2)
      oprot.writeI32(self.mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.host)
    value = (value * 31) ^ hash(self.mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoleSummary:
  """
  Attributes:
   - role
   - jobCount
   - cronJobCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role', None, None, ), # 1
    (2, TType.I32, 'jobCount', None, None, ), # 2
    (3, TType.I32, 'cronJobCount', None, None, ), # 3
  )

  def __init__(self, role=None, jobCount=None, cronJobCount=None,):
    self.role = role
    self.jobCount = jobCount
    self.cronJobCount = cronJobCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.jobCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cronJobCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoleSummary')
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRING, 1)
      oprot.writeString(self.role)
      oprot.writeFieldEnd()
    if self.jobCount is not None:
      oprot.writeFieldBegin('jobCount', TType.I32, 2)
      oprot.writeI32(self.jobCount)
      oprot.writeFieldEnd()
    if self.cronJobCount is not None:
      oprot.writeFieldBegin('cronJobCount', TType.I32, 3)
      oprot.writeI32(self.cronJobCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.role)
    value = (value * 31) ^ hash(self.jobCount)
    value = (value * 31) ^ hash(self.cronJobCount)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Hosts:
  """
  Attributes:
   - hostNames
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'hostNames', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, hostNames=None,):
    self.hostNames = hostNames

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.hostNames = set()
          (_etype147, _size144) = iprot.readSetBegin()
          for _i148 in range(_size144):
            _elem149 = iprot.readString()
            self.hostNames.add(_elem149)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Hosts')
    if self.hostNames is not None:
      oprot.writeFieldBegin('hostNames', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.hostNames))
      for iter150 in self.hostNames:
        oprot.writeString(iter150)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hostNames)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PendingReason:
  """
  Attributes:
   - taskId
   - reason
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'taskId', None, None, ), # 1
    (2, TType.STRING, 'reason', None, None, ), # 2
  )

  def __init__(self, taskId=None, reason=None,):
    self.taskId = taskId
    self.reason = reason

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.taskId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.reason = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PendingReason')
    if self.taskId is not None:
      oprot.writeFieldBegin('taskId', TType.STRING, 1)
      oprot.writeString(self.taskId)
      oprot.writeFieldEnd()
    if self.reason is not None:
      oprot.writeFieldBegin('reason', TType.STRING, 2)
      oprot.writeString(self.reason)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.taskId)
    value = (value * 31) ^ hash(self.reason)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobUpdateKey:
  """
  Job update key.

  Attributes:
   - job: Job being updated
   - id: Update ID.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'job', (JobKey, JobKey.thrift_spec), None, ), # 1
    (2, TType.STRING, 'id', None, None, ), # 2
  )

  def __init__(self, job=None, id=None,):
    self.job = job
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.job = JobKey()
          self.job.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.id = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateKey')
    if self.job is not None:
      oprot.writeFieldBegin('job', TType.STRUCT, 1)
      self.job.write(oprot)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 2)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.job)
    value = (value * 31) ^ hash(self.id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobUpdateSettings:
  """
  Job update thresholds and limits.

  Attributes:
   - updateGroupSize: Max number of instances being updated at any given moment.
   - maxPerInstanceFailures: Max number of instance failures to tolerate before marking instance as FAILED.
   - maxFailedInstances: Max number of FAILED instances to tolerate before terminating the update.
   - maxWaitToInstanceRunningMs: Max time to wait until an instance reaches RUNNING state.
   - minWaitInInstanceRunningMs: Min time to watch a RUNNING instance.
   - rollbackOnFailure: If true, enables failed update rollback.
   - updateOnlyTheseInstances: Instance IDs to act on. All instances will be affected if this is not set.
   - waitForBatchCompletion: If true, use updateGroupSize as strict batching boundaries, and avoid proceeding to another
  batch until the preceding batch finishes updating.
   - blockIfNoPulsesAfterMs: If set, requires external calls to pulseJobUpdate RPC within the specified rate for the
  update to make progress. If no pulses received within specified interval the update will
  block. A blocked update is unable to continue but retains its current status. It may only get
  unblocked by a fresh pulseJobUpdate call.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'updateGroupSize', None, None, ), # 1
    (2, TType.I32, 'maxPerInstanceFailures', None, None, ), # 2
    (3, TType.I32, 'maxFailedInstances', None, None, ), # 3
    (4, TType.I32, 'maxWaitToInstanceRunningMs', None, None, ), # 4
    (5, TType.I32, 'minWaitInInstanceRunningMs', None, None, ), # 5
    (6, TType.BOOL, 'rollbackOnFailure', None, None, ), # 6
    (7, TType.SET, 'updateOnlyTheseInstances', (TType.STRUCT,(Range, Range.thrift_spec)), None, ), # 7
    (8, TType.BOOL, 'waitForBatchCompletion', None, None, ), # 8
    (9, TType.I32, 'blockIfNoPulsesAfterMs', None, None, ), # 9
  )

  def __init__(self, updateGroupSize=None, maxPerInstanceFailures=None, maxFailedInstances=None, maxWaitToInstanceRunningMs=None, minWaitInInstanceRunningMs=None, rollbackOnFailure=None, updateOnlyTheseInstances=None, waitForBatchCompletion=None, blockIfNoPulsesAfterMs=None,):
    self.updateGroupSize = updateGroupSize
    self.maxPerInstanceFailures = maxPerInstanceFailures
    self.maxFailedInstances = maxFailedInstances
    self.maxWaitToInstanceRunningMs = maxWaitToInstanceRunningMs
    self.minWaitInInstanceRunningMs = minWaitInInstanceRunningMs
    self.rollbackOnFailure = rollbackOnFailure
    self.updateOnlyTheseInstances = updateOnlyTheseInstances
    self.waitForBatchCompletion = waitForBatchCompletion
    self.blockIfNoPulsesAfterMs = blockIfNoPulsesAfterMs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.updateGroupSize = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.maxPerInstanceFailures = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxFailedInstances = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.maxWaitToInstanceRunningMs = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.minWaitInInstanceRunningMs = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.rollbackOnFailure = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.updateOnlyTheseInstances = set()
          (_etype154, _size151) = iprot.readSetBegin()
          for _i155 in range(_size151):
            _elem156 = Range()
            _elem156.read(iprot)
            self.updateOnlyTheseInstances.add(_elem156)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.waitForBatchCompletion = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.blockIfNoPulsesAfterMs = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateSettings')
    if self.updateGroupSize is not None:
      oprot.writeFieldBegin('updateGroupSize', TType.I32, 1)
      oprot.writeI32(self.updateGroupSize)
      oprot.writeFieldEnd()
    if self.maxPerInstanceFailures is not None:
      oprot.writeFieldBegin('maxPerInstanceFailures', TType.I32, 2)
      oprot.writeI32(self.maxPerInstanceFailures)
      oprot.writeFieldEnd()
    if self.maxFailedInstances is not None:
      oprot.writeFieldBegin('maxFailedInstances', TType.I32, 3)
      oprot.writeI32(self.maxFailedInstances)
      oprot.writeFieldEnd()
    if self.maxWaitToInstanceRunningMs is not None:
      oprot.writeFieldBegin('maxWaitToInstanceRunningMs', TType.I32, 4)
      oprot.writeI32(self.maxWaitToInstanceRunningMs)
      oprot.writeFieldEnd()
    if self.minWaitInInstanceRunningMs is not None:
      oprot.writeFieldBegin('minWaitInInstanceRunningMs', TType.I32, 5)
      oprot.writeI32(self.minWaitInInstanceRunningMs)
      oprot.writeFieldEnd()
    if self.rollbackOnFailure is not None:
      oprot.writeFieldBegin('rollbackOnFailure', TType.BOOL, 6)
      oprot.writeBool(self.rollbackOnFailure)
      oprot.writeFieldEnd()
    if self.updateOnlyTheseInstances is not None:
      oprot.writeFieldBegin('updateOnlyTheseInstances', TType.SET, 7)
      oprot.writeSetBegin(TType.STRUCT, len(self.updateOnlyTheseInstances))
      for iter157 in self.updateOnlyTheseInstances:
        iter157.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.waitForBatchCompletion is not None:
      oprot.writeFieldBegin('waitForBatchCompletion', TType.BOOL, 8)
      oprot.writeBool(self.waitForBatchCompletion)
      oprot.writeFieldEnd()
    if self.blockIfNoPulsesAfterMs is not None:
      oprot.writeFieldBegin('blockIfNoPulsesAfterMs', TType.I32, 9)
      oprot.writeI32(self.blockIfNoPulsesAfterMs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.updateGroupSize)
    value = (value * 31) ^ hash(self.maxPerInstanceFailures)
    value = (value * 31) ^ hash(self.maxFailedInstances)
    value = (value * 31) ^ hash(self.maxWaitToInstanceRunningMs)
    value = (value * 31) ^ hash(self.minWaitInInstanceRunningMs)
    value = (value * 31) ^ hash(self.rollbackOnFailure)
    value = (value * 31) ^ hash(self.updateOnlyTheseInstances)
    value = (value * 31) ^ hash(self.waitForBatchCompletion)
    value = (value * 31) ^ hash(self.blockIfNoPulsesAfterMs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobUpdateEvent:
  """
  Event marking a state transition in job update lifecycle.

  Attributes:
   - status: Update status.
   - timestampMs: Epoch timestamp in milliseconds.
   - user: User who performed this event (if user-initiated).
   - message: Message from the user (for user-initiated transitions) or the scheduler about why the state was
  changed.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status', None, None, ), # 1
    (2, TType.I64, 'timestampMs', None, None, ), # 2
    (3, TType.STRING, 'user', None, None, ), # 3
    (4, TType.STRING, 'message', None, None, ), # 4
  )

  def __init__(self, status=None, timestampMs=None, user=None, message=None,):
    self.status = status
    self.timestampMs = timestampMs
    self.user = user
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestampMs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateEvent')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 1)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.timestampMs is not None:
      oprot.writeFieldBegin('timestampMs', TType.I64, 2)
      oprot.writeI64(self.timestampMs)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 3)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 4)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.timestampMs)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobInstanceUpdateEvent:
  """
  Event marking a state transition in job instance update lifecycle.

  Attributes:
   - instanceId: Job instance ID.
   - timestampMs: Epoch timestamp in milliseconds.
   - action: Job update action taken on the instance.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'instanceId', None, None, ), # 1
    (2, TType.I64, 'timestampMs', None, None, ), # 2
    (3, TType.I32, 'action', None, None, ), # 3
  )

  def __init__(self, instanceId=None, timestampMs=None, action=None,):
    self.instanceId = instanceId
    self.timestampMs = timestampMs
    self.action = action

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.instanceId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestampMs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.action = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobInstanceUpdateEvent')
    if self.instanceId is not None:
      oprot.writeFieldBegin('instanceId', TType.I32, 1)
      oprot.writeI32(self.instanceId)
      oprot.writeFieldEnd()
    if self.timestampMs is not None:
      oprot.writeFieldBegin('timestampMs', TType.I64, 2)
      oprot.writeI64(self.timestampMs)
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 3)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.instanceId)
    value = (value * 31) ^ hash(self.timestampMs)
    value = (value * 31) ^ hash(self.action)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InstanceTaskConfig:
  """
  Maps instance IDs to TaskConfigs it.

  Attributes:
   - task: A TaskConfig associated with instances.
   - instances: Instances associated with the TaskConfig.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'task', (TaskConfig, TaskConfig.thrift_spec), None, ), # 1
    (2, TType.SET, 'instances', (TType.STRUCT,(Range, Range.thrift_spec)), None, ), # 2
  )

  def __init__(self, task=None, instances=None,):
    self.task = task
    self.instances = instances

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.task = TaskConfig()
          self.task.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.instances = set()
          (_etype161, _size158) = iprot.readSetBegin()
          for _i162 in range(_size158):
            _elem163 = Range()
            _elem163.read(iprot)
            self.instances.add(_elem163)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InstanceTaskConfig')
    if self.task is not None:
      oprot.writeFieldBegin('task', TType.STRUCT, 1)
      self.task.write(oprot)
      oprot.writeFieldEnd()
    if self.instances is not None:
      oprot.writeFieldBegin('instances', TType.SET, 2)
      oprot.writeSetBegin(TType.STRUCT, len(self.instances))
      for iter164 in self.instances:
        iter164.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.task)
    value = (value * 31) ^ hash(self.instances)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobUpdateState:
  """
  Current job update state including status and created/modified timestamps.

  Attributes:
   - status: Current status of the update.
   - createdTimestampMs: Created timestamp in milliseconds.
   - lastModifiedTimestampMs: Last modified timestamp in milliseconds.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status', None, None, ), # 1
    (2, TType.I64, 'createdTimestampMs', None, None, ), # 2
    (3, TType.I64, 'lastModifiedTimestampMs', None, None, ), # 3
  )

  def __init__(self, status=None, createdTimestampMs=None, lastModifiedTimestampMs=None,):
    self.status = status
    self.createdTimestampMs = createdTimestampMs
    self.lastModifiedTimestampMs = lastModifiedTimestampMs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.createdTimestampMs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.lastModifiedTimestampMs = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateState')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 1)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.createdTimestampMs is not None:
      oprot.writeFieldBegin('createdTimestampMs', TType.I64, 2)
      oprot.writeI64(self.createdTimestampMs)
      oprot.writeFieldEnd()
    if self.lastModifiedTimestampMs is not None:
      oprot.writeFieldBegin('lastModifiedTimestampMs', TType.I64, 3)
      oprot.writeI64(self.lastModifiedTimestampMs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.createdTimestampMs)
    value = (value * 31) ^ hash(self.lastModifiedTimestampMs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobUpdateSummary:
  """
  Summary of the job update including job key, user and current state.

  Attributes:
   - updateId: Update ID.
   - jobKey: Job key.
   - key: Unique identifier for the update.
   - user: User initiated an update.
   - state: Current job update state.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'updateId', None, None, ), # 1
    (2, TType.STRUCT, 'jobKey', (JobKey, JobKey.thrift_spec), None, ), # 2
    (3, TType.STRING, 'user', None, None, ), # 3
    (4, TType.STRUCT, 'state', (JobUpdateState, JobUpdateState.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'key', (JobUpdateKey, JobUpdateKey.thrift_spec), None, ), # 5
  )

  def __init__(self, updateId=None, jobKey=None, key=None, user=None, state=None,):
    self.updateId = updateId
    self.jobKey = jobKey
    self.key = key
    self.user = user
    self.state = state

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.updateId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.jobKey = JobKey()
          self.jobKey.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.key = JobUpdateKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.state = JobUpdateState()
          self.state.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateSummary')
    if self.updateId is not None:
      oprot.writeFieldBegin('updateId', TType.STRING, 1)
      oprot.writeString(self.updateId)
      oprot.writeFieldEnd()
    if self.jobKey is not None:
      oprot.writeFieldBegin('jobKey', TType.STRUCT, 2)
      self.jobKey.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 3)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.STRUCT, 4)
      self.state.write(oprot)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 5)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.updateId)
    value = (value * 31) ^ hash(self.jobKey)
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.state)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobUpdateInstructions:
  """
  Update configuration and setting details.

  Attributes:
   - initialState: Actual InstanceId -> TaskConfig mapping when the update was requested.
   - desiredState: Desired configuration when the update completes.
   - settings: Update specific settings.
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'initialState', (TType.STRUCT,(InstanceTaskConfig, InstanceTaskConfig.thrift_spec)), None, ), # 1
    (2, TType.STRUCT, 'desiredState', (InstanceTaskConfig, InstanceTaskConfig.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'settings', (JobUpdateSettings, JobUpdateSettings.thrift_spec), None, ), # 3
  )

  def __init__(self, initialState=None, desiredState=None, settings=None,):
    self.initialState = initialState
    self.desiredState = desiredState
    self.settings = settings

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.initialState = set()
          (_etype168, _size165) = iprot.readSetBegin()
          for _i169 in range(_size165):
            _elem170 = InstanceTaskConfig()
            _elem170.read(iprot)
            self.initialState.add(_elem170)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.desiredState = InstanceTaskConfig()
          self.desiredState.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.settings = JobUpdateSettings()
          self.settings.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateInstructions')
    if self.initialState is not None:
      oprot.writeFieldBegin('initialState', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.initialState))
      for iter171 in self.initialState:
        iter171.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.desiredState is not None:
      oprot.writeFieldBegin('desiredState', TType.STRUCT, 2)
      self.desiredState.write(oprot)
      oprot.writeFieldEnd()
    if self.settings is not None:
      oprot.writeFieldBegin('settings', TType.STRUCT, 3)
      self.settings.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.initialState)
    value = (value * 31) ^ hash(self.desiredState)
    value = (value * 31) ^ hash(self.settings)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobUpdate:
  """
  Full definition of the job update.

  Attributes:
   - summary: Update summary.
   - instructions: Update configuration.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'summary', (JobUpdateSummary, JobUpdateSummary.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'instructions', (JobUpdateInstructions, JobUpdateInstructions.thrift_spec), None, ), # 2
  )

  def __init__(self, summary=None, instructions=None,):
    self.summary = summary
    self.instructions = instructions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.summary = JobUpdateSummary()
          self.summary.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.instructions = JobUpdateInstructions()
          self.instructions.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdate')
    if self.summary is not None:
      oprot.writeFieldBegin('summary', TType.STRUCT, 1)
      self.summary.write(oprot)
      oprot.writeFieldEnd()
    if self.instructions is not None:
      oprot.writeFieldBegin('instructions', TType.STRUCT, 2)
      self.instructions.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.summary)
    value = (value * 31) ^ hash(self.instructions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobUpdateDetails:
  """
  Attributes:
   - update: Update definition.
   - updateEvents: History for this update.
   - instanceEvents: History for the individual instances updated.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'update', (JobUpdate, JobUpdate.thrift_spec), None, ), # 1
    (2, TType.LIST, 'updateEvents', (TType.STRUCT,(JobUpdateEvent, JobUpdateEvent.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'instanceEvents', (TType.STRUCT,(JobInstanceUpdateEvent, JobInstanceUpdateEvent.thrift_spec)), None, ), # 3
  )

  def __init__(self, update=None, updateEvents=None, instanceEvents=None,):
    self.update = update
    self.updateEvents = updateEvents
    self.instanceEvents = instanceEvents

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.update = JobUpdate()
          self.update.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.updateEvents = []
          (_etype175, _size172) = iprot.readListBegin()
          for _i176 in range(_size172):
            _elem177 = JobUpdateEvent()
            _elem177.read(iprot)
            self.updateEvents.append(_elem177)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.instanceEvents = []
          (_etype181, _size178) = iprot.readListBegin()
          for _i182 in range(_size178):
            _elem183 = JobInstanceUpdateEvent()
            _elem183.read(iprot)
            self.instanceEvents.append(_elem183)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateDetails')
    if self.update is not None:
      oprot.writeFieldBegin('update', TType.STRUCT, 1)
      self.update.write(oprot)
      oprot.writeFieldEnd()
    if self.updateEvents is not None:
      oprot.writeFieldBegin('updateEvents', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.updateEvents))
      for iter184 in self.updateEvents:
        iter184.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.instanceEvents is not None:
      oprot.writeFieldBegin('instanceEvents', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.instanceEvents))
      for iter185 in self.instanceEvents:
        iter185.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.update)
    value = (value * 31) ^ hash(self.updateEvents)
    value = (value * 31) ^ hash(self.instanceEvents)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobUpdateRequest:
  """
  A request to update the following instances of an existing job. Used by startUpdate.

  Attributes:
   - taskConfig: Desired TaskConfig to apply.
   - instanceCount: Desired number of instances of the task config.
   - settings: Update settings and limits.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'taskConfig', (TaskConfig, TaskConfig.thrift_spec), None, ), # 1
    (2, TType.I32, 'instanceCount', None, None, ), # 2
    (3, TType.STRUCT, 'settings', (JobUpdateSettings, JobUpdateSettings.thrift_spec), None, ), # 3
  )

  def __init__(self, taskConfig=None, instanceCount=None, settings=None,):
    self.taskConfig = taskConfig
    self.instanceCount = instanceCount
    self.settings = settings

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.taskConfig = TaskConfig()
          self.taskConfig.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.instanceCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.settings = JobUpdateSettings()
          self.settings.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateRequest')
    if self.taskConfig is not None:
      oprot.writeFieldBegin('taskConfig', TType.STRUCT, 1)
      self.taskConfig.write(oprot)
      oprot.writeFieldEnd()
    if self.instanceCount is not None:
      oprot.writeFieldBegin('instanceCount', TType.I32, 2)
      oprot.writeI32(self.instanceCount)
      oprot.writeFieldEnd()
    if self.settings is not None:
      oprot.writeFieldBegin('settings', TType.STRUCT, 3)
      self.settings.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.taskConfig)
    value = (value * 31) ^ hash(self.instanceCount)
    value = (value * 31) ^ hash(self.settings)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobUpdateQuery:
  """
  Contains a set of restrictions on matching job updates where all restrictions must be met
  (terms are AND'ed together).

  Attributes:
   - role: Job role.
   - key: Unique identifier for a job update.
   - jobKey: Job key.
   - user: User who created the update.
   - updateStatuses: Set of update statuses.
   - offset: Offset to serve data from. Used by pagination.
   - limit: Number or records to serve. Used by pagination.
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'role', None, None, ), # 2
    (3, TType.STRUCT, 'jobKey', (JobKey, JobKey.thrift_spec), None, ), # 3
    (4, TType.STRING, 'user', None, None, ), # 4
    (5, TType.SET, 'updateStatuses', (TType.I32,None), None, ), # 5
    (6, TType.I32, 'offset', None, None, ), # 6
    (7, TType.I32, 'limit', None, None, ), # 7
    (8, TType.STRUCT, 'key', (JobUpdateKey, JobUpdateKey.thrift_spec), None, ), # 8
  )

  def __init__(self, role=None, key=None, jobKey=None, user=None, updateStatuses=None, offset=None, limit=None,):
    self.role = role
    self.key = key
    self.jobKey = jobKey
    self.user = user
    self.updateStatuses = updateStatuses
    self.offset = offset
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.role = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.key = JobUpdateKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.jobKey = JobKey()
          self.jobKey.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.SET:
          self.updateStatuses = set()
          (_etype189, _size186) = iprot.readSetBegin()
          for _i190 in range(_size186):
            _elem191 = iprot.readI32()
            self.updateStatuses.add(_elem191)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobUpdateQuery')
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRING, 2)
      oprot.writeString(self.role)
      oprot.writeFieldEnd()
    if self.jobKey is not None:
      oprot.writeFieldBegin('jobKey', TType.STRUCT, 3)
      self.jobKey.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 4)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.updateStatuses is not None:
      oprot.writeFieldBegin('updateStatuses', TType.SET, 5)
      oprot.writeSetBegin(TType.I32, len(self.updateStatuses))
      for iter192 in self.updateStatuses:
        oprot.writeI32(iter192)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 6)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 7)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 8)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.role)
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.jobKey)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.updateStatuses)
    value = (value * 31) ^ hash(self.offset)
    value = (value * 31) ^ hash(self.limit)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListBackupsResult:
  """
  Attributes:
   - backups
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'backups', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, backups=None,):
    self.backups = backups

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.backups = set()
          (_etype196, _size193) = iprot.readSetBegin()
          for _i197 in range(_size193):
            _elem198 = iprot.readString()
            self.backups.add(_elem198)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListBackupsResult')
    if self.backups is not None:
      oprot.writeFieldBegin('backups', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.backups))
      for iter199 in self.backups:
        oprot.writeString(iter199)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.backups)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StartMaintenanceResult:
  """
  Attributes:
   - statuses
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'statuses', (TType.STRUCT,(HostStatus, HostStatus.thrift_spec)), None, ), # 1
  )

  def __init__(self, statuses=None,):
    self.statuses = statuses

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.statuses = set()
          (_etype203, _size200) = iprot.readSetBegin()
          for _i204 in range(_size200):
            _elem205 = HostStatus()
            _elem205.read(iprot)
            self.statuses.add(_elem205)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StartMaintenanceResult')
    if self.statuses is not None:
      oprot.writeFieldBegin('statuses', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.statuses))
      for iter206 in self.statuses:
        iter206.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.statuses)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DrainHostsResult:
  """
  Attributes:
   - statuses
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'statuses', (TType.STRUCT,(HostStatus, HostStatus.thrift_spec)), None, ), # 1
  )

  def __init__(self, statuses=None,):
    self.statuses = statuses

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.statuses = set()
          (_etype210, _size207) = iprot.readSetBegin()
          for _i211 in range(_size207):
            _elem212 = HostStatus()
            _elem212.read(iprot)
            self.statuses.add(_elem212)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DrainHostsResult')
    if self.statuses is not None:
      oprot.writeFieldBegin('statuses', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.statuses))
      for iter213 in self.statuses:
        iter213.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.statuses)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryRecoveryResult:
  """
  Attributes:
   - tasks
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'tasks', (TType.STRUCT,(ScheduledTask, ScheduledTask.thrift_spec)), None, ), # 1
  )

  def __init__(self, tasks=None,):
    self.tasks = tasks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.tasks = set()
          (_etype217, _size214) = iprot.readSetBegin()
          for _i218 in range(_size214):
            _elem219 = ScheduledTask()
            _elem219.read(iprot)
            self.tasks.add(_elem219)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryRecoveryResult')
    if self.tasks is not None:
      oprot.writeFieldBegin('tasks', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.tasks))
      for iter220 in self.tasks:
        iter220.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tasks)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MaintenanceStatusResult:
  """
  Attributes:
   - statuses
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'statuses', (TType.STRUCT,(HostStatus, HostStatus.thrift_spec)), None, ), # 1
  )

  def __init__(self, statuses=None,):
    self.statuses = statuses

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.statuses = set()
          (_etype224, _size221) = iprot.readSetBegin()
          for _i225 in range(_size221):
            _elem226 = HostStatus()
            _elem226.read(iprot)
            self.statuses.add(_elem226)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MaintenanceStatusResult')
    if self.statuses is not None:
      oprot.writeFieldBegin('statuses', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.statuses))
      for iter227 in self.statuses:
        iter227.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.statuses)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EndMaintenanceResult:
  """
  Attributes:
   - statuses
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'statuses', (TType.STRUCT,(HostStatus, HostStatus.thrift_spec)), None, ), # 1
  )

  def __init__(self, statuses=None,):
    self.statuses = statuses

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.statuses = set()
          (_etype231, _size228) = iprot.readSetBegin()
          for _i232 in range(_size228):
            _elem233 = HostStatus()
            _elem233.read(iprot)
            self.statuses.add(_elem233)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EndMaintenanceResult')
    if self.statuses is not None:
      oprot.writeFieldBegin('statuses', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.statuses))
      for iter234 in self.statuses:
        iter234.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.statuses)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RoleSummaryResult:
  """
  Attributes:
   - summaries
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'summaries', (TType.STRUCT,(RoleSummary, RoleSummary.thrift_spec)), None, ), # 1
  )

  def __init__(self, summaries=None,):
    self.summaries = summaries

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.summaries = set()
          (_etype238, _size235) = iprot.readSetBegin()
          for _i239 in range(_size235):
            _elem240 = RoleSummary()
            _elem240.read(iprot)
            self.summaries.add(_elem240)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RoleSummaryResult')
    if self.summaries is not None:
      oprot.writeFieldBegin('summaries', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.summaries))
      for iter241 in self.summaries:
        iter241.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.summaries)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobSummaryResult:
  """
  Attributes:
   - summaries
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'summaries', (TType.STRUCT,(JobSummary, JobSummary.thrift_spec)), None, ), # 1
  )

  def __init__(self, summaries=None,):
    self.summaries = summaries

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.summaries = set()
          (_etype245, _size242) = iprot.readSetBegin()
          for _i246 in range(_size242):
            _elem247 = JobSummary()
            _elem247.read(iprot)
            self.summaries.add(_elem247)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobSummaryResult')
    if self.summaries is not None:
      oprot.writeFieldBegin('summaries', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.summaries))
      for iter248 in self.summaries:
        iter248.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.summaries)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetLocksResult:
  """
  Attributes:
   - locks
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'locks', (TType.STRUCT,(Lock, Lock.thrift_spec)), None, ), # 1
  )

  def __init__(self, locks=None,):
    self.locks = locks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.locks = set()
          (_etype252, _size249) = iprot.readSetBegin()
          for _i253 in range(_size249):
            _elem254 = Lock()
            _elem254.read(iprot)
            self.locks.add(_elem254)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetLocksResult')
    if self.locks is not None:
      oprot.writeFieldBegin('locks', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.locks))
      for iter255 in self.locks:
        iter255.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.locks)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConfigSummaryResult:
  """
  Attributes:
   - summary
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'summary', (ConfigSummary, ConfigSummary.thrift_spec), None, ), # 1
  )

  def __init__(self, summary=None,):
    self.summary = summary

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.summary = ConfigSummary()
          self.summary.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfigSummaryResult')
    if self.summary is not None:
      oprot.writeFieldBegin('summary', TType.STRUCT, 1)
      self.summary.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.summary)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetPendingReasonResult:
  """
  Attributes:
   - reasons
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'reasons', (TType.STRUCT,(PendingReason, PendingReason.thrift_spec)), None, ), # 1
  )

  def __init__(self, reasons=None,):
    self.reasons = reasons

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.reasons = set()
          (_etype259, _size256) = iprot.readSetBegin()
          for _i260 in range(_size256):
            _elem261 = PendingReason()
            _elem261.read(iprot)
            self.reasons.add(_elem261)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetPendingReasonResult')
    if self.reasons is not None:
      oprot.writeFieldBegin('reasons', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.reasons))
      for iter262 in self.reasons:
        iter262.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.reasons)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StartJobUpdateResult:
  """
  Result of the startUpdate call.

  Attributes:
   - key: Unique identifier for the job update.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'key', (JobUpdateKey, JobUpdateKey.thrift_spec), None, ), # 1
  )

  def __init__(self, key=None,):
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = JobUpdateKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StartJobUpdateResult')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetJobUpdateSummariesResult:
  """
  Result of the getJobUpdateSummaries call.

  Attributes:
   - updateSummaries
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'updateSummaries', (TType.STRUCT,(JobUpdateSummary, JobUpdateSummary.thrift_spec)), None, ), # 1
  )

  def __init__(self, updateSummaries=None,):
    self.updateSummaries = updateSummaries

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.updateSummaries = []
          (_etype266, _size263) = iprot.readListBegin()
          for _i267 in range(_size263):
            _elem268 = JobUpdateSummary()
            _elem268.read(iprot)
            self.updateSummaries.append(_elem268)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetJobUpdateSummariesResult')
    if self.updateSummaries is not None:
      oprot.writeFieldBegin('updateSummaries', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.updateSummaries))
      for iter269 in self.updateSummaries:
        iter269.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.updateSummaries)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetJobUpdateDetailsResult:
  """
  Result of the getJobUpdateDetails call.

  Attributes:
   - details
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'details', (JobUpdateDetails, JobUpdateDetails.thrift_spec), None, ), # 1
  )

  def __init__(self, details=None,):
    self.details = details

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.details = JobUpdateDetails()
          self.details.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetJobUpdateDetailsResult')
    if self.details is not None:
      oprot.writeFieldBegin('details', TType.STRUCT, 1)
      self.details.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.details)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PulseJobUpdateResult:
  """
  Result of the pulseJobUpdate call.

  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status', None, None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PulseJobUpdateResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 1)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ServerInfo:
  """
  Information about the scheduler.

  Attributes:
   - clusterName
   - thriftAPIVersion
   - statsUrlPrefix: A url prefix for job container stats.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clusterName', None, None, ), # 1
    (2, TType.I32, 'thriftAPIVersion', None, None, ), # 2
    (3, TType.STRING, 'statsUrlPrefix', None, None, ), # 3
  )

  def __init__(self, clusterName=None, thriftAPIVersion=None, statsUrlPrefix=None,):
    self.clusterName = clusterName
    self.thriftAPIVersion = thriftAPIVersion
    self.statsUrlPrefix = statsUrlPrefix

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clusterName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.thriftAPIVersion = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.statsUrlPrefix = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ServerInfo')
    if self.clusterName is not None:
      oprot.writeFieldBegin('clusterName', TType.STRING, 1)
      oprot.writeString(self.clusterName)
      oprot.writeFieldEnd()
    if self.thriftAPIVersion is not None:
      oprot.writeFieldBegin('thriftAPIVersion', TType.I32, 2)
      oprot.writeI32(self.thriftAPIVersion)
      oprot.writeFieldEnd()
    if self.statsUrlPrefix is not None:
      oprot.writeFieldBegin('statsUrlPrefix', TType.STRING, 3)
      oprot.writeString(self.statsUrlPrefix)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.clusterName)
    value = (value * 31) ^ hash(self.thriftAPIVersion)
    value = (value * 31) ^ hash(self.statsUrlPrefix)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Result:
  """
  Attributes:
   - populateJobResult
   - scheduleStatusResult
   - getJobsResult
   - getQuotaResult
   - listBackupsResult
   - startMaintenanceResult
   - drainHostsResult
   - queryRecoveryResult
   - maintenanceStatusResult
   - endMaintenanceResult
   - getVersionResult
   - acquireLockResult
   - roleSummaryResult
   - jobSummaryResult
   - getLocksResult
   - configSummaryResult
   - getPendingReasonResult
   - startJobUpdateResult
   - getJobUpdateSummariesResult
   - getJobUpdateDetailsResult
   - pulseJobUpdateResult
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'populateJobResult', (PopulateJobResult, PopulateJobResult.thrift_spec), None, ), # 1
    None, # 2
    (3, TType.STRUCT, 'scheduleStatusResult', (ScheduleStatusResult, ScheduleStatusResult.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'getJobsResult', (GetJobsResult, GetJobsResult.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'getQuotaResult', (GetQuotaResult, GetQuotaResult.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'listBackupsResult', (ListBackupsResult, ListBackupsResult.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'startMaintenanceResult', (StartMaintenanceResult, StartMaintenanceResult.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'drainHostsResult', (DrainHostsResult, DrainHostsResult.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'queryRecoveryResult', (QueryRecoveryResult, QueryRecoveryResult.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'maintenanceStatusResult', (MaintenanceStatusResult, MaintenanceStatusResult.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'endMaintenanceResult', (EndMaintenanceResult, EndMaintenanceResult.thrift_spec), None, ), # 11
    None, # 12
    None, # 13
    None, # 14
    (15, TType.STRUCT, 'getVersionResult', (APIVersion, APIVersion.thrift_spec), None, ), # 15
    (16, TType.STRUCT, 'acquireLockResult', (AcquireLockResult, AcquireLockResult.thrift_spec), None, ), # 16
    (17, TType.STRUCT, 'roleSummaryResult', (RoleSummaryResult, RoleSummaryResult.thrift_spec), None, ), # 17
    (18, TType.STRUCT, 'jobSummaryResult', (JobSummaryResult, JobSummaryResult.thrift_spec), None, ), # 18
    (19, TType.STRUCT, 'getLocksResult', (GetLocksResult, GetLocksResult.thrift_spec), None, ), # 19
    (20, TType.STRUCT, 'configSummaryResult', (ConfigSummaryResult, ConfigSummaryResult.thrift_spec), None, ), # 20
    (21, TType.STRUCT, 'getPendingReasonResult', (GetPendingReasonResult, GetPendingReasonResult.thrift_spec), None, ), # 21
    (22, TType.STRUCT, 'startJobUpdateResult', (StartJobUpdateResult, StartJobUpdateResult.thrift_spec), None, ), # 22
    (23, TType.STRUCT, 'getJobUpdateSummariesResult', (GetJobUpdateSummariesResult, GetJobUpdateSummariesResult.thrift_spec), None, ), # 23
    (24, TType.STRUCT, 'getJobUpdateDetailsResult', (GetJobUpdateDetailsResult, GetJobUpdateDetailsResult.thrift_spec), None, ), # 24
    (25, TType.STRUCT, 'pulseJobUpdateResult', (PulseJobUpdateResult, PulseJobUpdateResult.thrift_spec), None, ), # 25
  )

  def __init__(self, populateJobResult=None, scheduleStatusResult=None, getJobsResult=None, getQuotaResult=None, listBackupsResult=None, startMaintenanceResult=None, drainHostsResult=None, queryRecoveryResult=None, maintenanceStatusResult=None, endMaintenanceResult=None, getVersionResult=None, acquireLockResult=None, roleSummaryResult=None, jobSummaryResult=None, getLocksResult=None, configSummaryResult=None, getPendingReasonResult=None, startJobUpdateResult=None, getJobUpdateSummariesResult=None, getJobUpdateDetailsResult=None, pulseJobUpdateResult=None,):
    self.populateJobResult = populateJobResult
    self.scheduleStatusResult = scheduleStatusResult
    self.getJobsResult = getJobsResult
    self.getQuotaResult = getQuotaResult
    self.listBackupsResult = listBackupsResult
    self.startMaintenanceResult = startMaintenanceResult
    self.drainHostsResult = drainHostsResult
    self.queryRecoveryResult = queryRecoveryResult
    self.maintenanceStatusResult = maintenanceStatusResult
    self.endMaintenanceResult = endMaintenanceResult
    self.getVersionResult = getVersionResult
    self.acquireLockResult = acquireLockResult
    self.roleSummaryResult = roleSummaryResult
    self.jobSummaryResult = jobSummaryResult
    self.getLocksResult = getLocksResult
    self.configSummaryResult = configSummaryResult
    self.getPendingReasonResult = getPendingReasonResult
    self.startJobUpdateResult = startJobUpdateResult
    self.getJobUpdateSummariesResult = getJobUpdateSummariesResult
    self.getJobUpdateDetailsResult = getJobUpdateDetailsResult
    self.pulseJobUpdateResult = pulseJobUpdateResult

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.populateJobResult = PopulateJobResult()
          self.populateJobResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.scheduleStatusResult = ScheduleStatusResult()
          self.scheduleStatusResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.getJobsResult = GetJobsResult()
          self.getJobsResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.getQuotaResult = GetQuotaResult()
          self.getQuotaResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.listBackupsResult = ListBackupsResult()
          self.listBackupsResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.startMaintenanceResult = StartMaintenanceResult()
          self.startMaintenanceResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.drainHostsResult = DrainHostsResult()
          self.drainHostsResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.queryRecoveryResult = QueryRecoveryResult()
          self.queryRecoveryResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.maintenanceStatusResult = MaintenanceStatusResult()
          self.maintenanceStatusResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.endMaintenanceResult = EndMaintenanceResult()
          self.endMaintenanceResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.getVersionResult = APIVersion()
          self.getVersionResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRUCT:
          self.acquireLockResult = AcquireLockResult()
          self.acquireLockResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRUCT:
          self.roleSummaryResult = RoleSummaryResult()
          self.roleSummaryResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRUCT:
          self.jobSummaryResult = JobSummaryResult()
          self.jobSummaryResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.STRUCT:
          self.getLocksResult = GetLocksResult()
          self.getLocksResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRUCT:
          self.configSummaryResult = ConfigSummaryResult()
          self.configSummaryResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRUCT:
          self.getPendingReasonResult = GetPendingReasonResult()
          self.getPendingReasonResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.STRUCT:
          self.startJobUpdateResult = StartJobUpdateResult()
          self.startJobUpdateResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRUCT:
          self.getJobUpdateSummariesResult = GetJobUpdateSummariesResult()
          self.getJobUpdateSummariesResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.STRUCT:
          self.getJobUpdateDetailsResult = GetJobUpdateDetailsResult()
          self.getJobUpdateDetailsResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.STRUCT:
          self.pulseJobUpdateResult = PulseJobUpdateResult()
          self.pulseJobUpdateResult.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Result')
    if self.populateJobResult is not None:
      oprot.writeFieldBegin('populateJobResult', TType.STRUCT, 1)
      self.populateJobResult.write(oprot)
      oprot.writeFieldEnd()
    if self.scheduleStatusResult is not None:
      oprot.writeFieldBegin('scheduleStatusResult', TType.STRUCT, 3)
      self.scheduleStatusResult.write(oprot)
      oprot.writeFieldEnd()
    if self.getJobsResult is not None:
      oprot.writeFieldBegin('getJobsResult', TType.STRUCT, 4)
      self.getJobsResult.write(oprot)
      oprot.writeFieldEnd()
    if self.getQuotaResult is not None:
      oprot.writeFieldBegin('getQuotaResult', TType.STRUCT, 5)
      self.getQuotaResult.write(oprot)
      oprot.writeFieldEnd()
    if self.listBackupsResult is not None:
      oprot.writeFieldBegin('listBackupsResult', TType.STRUCT, 6)
      self.listBackupsResult.write(oprot)
      oprot.writeFieldEnd()
    if self.startMaintenanceResult is not None:
      oprot.writeFieldBegin('startMaintenanceResult', TType.STRUCT, 7)
      self.startMaintenanceResult.write(oprot)
      oprot.writeFieldEnd()
    if self.drainHostsResult is not None:
      oprot.writeFieldBegin('drainHostsResult', TType.STRUCT, 8)
      self.drainHostsResult.write(oprot)
      oprot.writeFieldEnd()
    if self.queryRecoveryResult is not None:
      oprot.writeFieldBegin('queryRecoveryResult', TType.STRUCT, 9)
      self.queryRecoveryResult.write(oprot)
      oprot.writeFieldEnd()
    if self.maintenanceStatusResult is not None:
      oprot.writeFieldBegin('maintenanceStatusResult', TType.STRUCT, 10)
      self.maintenanceStatusResult.write(oprot)
      oprot.writeFieldEnd()
    if self.endMaintenanceResult is not None:
      oprot.writeFieldBegin('endMaintenanceResult', TType.STRUCT, 11)
      self.endMaintenanceResult.write(oprot)
      oprot.writeFieldEnd()
    if self.getVersionResult is not None:
      oprot.writeFieldBegin('getVersionResult', TType.STRUCT, 15)
      self.getVersionResult.write(oprot)
      oprot.writeFieldEnd()
    if self.acquireLockResult is not None:
      oprot.writeFieldBegin('acquireLockResult', TType.STRUCT, 16)
      self.acquireLockResult.write(oprot)
      oprot.writeFieldEnd()
    if self.roleSummaryResult is not None:
      oprot.writeFieldBegin('roleSummaryResult', TType.STRUCT, 17)
      self.roleSummaryResult.write(oprot)
      oprot.writeFieldEnd()
    if self.jobSummaryResult is not None:
      oprot.writeFieldBegin('jobSummaryResult', TType.STRUCT, 18)
      self.jobSummaryResult.write(oprot)
      oprot.writeFieldEnd()
    if self.getLocksResult is not None:
      oprot.writeFieldBegin('getLocksResult', TType.STRUCT, 19)
      self.getLocksResult.write(oprot)
      oprot.writeFieldEnd()
    if self.configSummaryResult is not None:
      oprot.writeFieldBegin('configSummaryResult', TType.STRUCT, 20)
      self.configSummaryResult.write(oprot)
      oprot.writeFieldEnd()
    if self.getPendingReasonResult is not None:
      oprot.writeFieldBegin('getPendingReasonResult', TType.STRUCT, 21)
      self.getPendingReasonResult.write(oprot)
      oprot.writeFieldEnd()
    if self.startJobUpdateResult is not None:
      oprot.writeFieldBegin('startJobUpdateResult', TType.STRUCT, 22)
      self.startJobUpdateResult.write(oprot)
      oprot.writeFieldEnd()
    if self.getJobUpdateSummariesResult is not None:
      oprot.writeFieldBegin('getJobUpdateSummariesResult', TType.STRUCT, 23)
      self.getJobUpdateSummariesResult.write(oprot)
      oprot.writeFieldEnd()
    if self.getJobUpdateDetailsResult is not None:
      oprot.writeFieldBegin('getJobUpdateDetailsResult', TType.STRUCT, 24)
      self.getJobUpdateDetailsResult.write(oprot)
      oprot.writeFieldEnd()
    if self.pulseJobUpdateResult is not None:
      oprot.writeFieldBegin('pulseJobUpdateResult', TType.STRUCT, 25)
      self.pulseJobUpdateResult.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.populateJobResult)
    value = (value * 31) ^ hash(self.scheduleStatusResult)
    value = (value * 31) ^ hash(self.getJobsResult)
    value = (value * 31) ^ hash(self.getQuotaResult)
    value = (value * 31) ^ hash(self.listBackupsResult)
    value = (value * 31) ^ hash(self.startMaintenanceResult)
    value = (value * 31) ^ hash(self.drainHostsResult)
    value = (value * 31) ^ hash(self.queryRecoveryResult)
    value = (value * 31) ^ hash(self.maintenanceStatusResult)
    value = (value * 31) ^ hash(self.endMaintenanceResult)
    value = (value * 31) ^ hash(self.getVersionResult)
    value = (value * 31) ^ hash(self.acquireLockResult)
    value = (value * 31) ^ hash(self.roleSummaryResult)
    value = (value * 31) ^ hash(self.jobSummaryResult)
    value = (value * 31) ^ hash(self.getLocksResult)
    value = (value * 31) ^ hash(self.configSummaryResult)
    value = (value * 31) ^ hash(self.getPendingReasonResult)
    value = (value * 31) ^ hash(self.startJobUpdateResult)
    value = (value * 31) ^ hash(self.getJobUpdateSummariesResult)
    value = (value * 31) ^ hash(self.getJobUpdateDetailsResult)
    value = (value * 31) ^ hash(self.pulseJobUpdateResult)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResponseDetail:
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResponseDetail')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Response:
  """
  Attributes:
   - responseCode
   - serverInfo
   - result: Payload from the invoked RPC.
   - details: Messages from the server relevant to the request, such as warnings or use of deprecated
  features.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'responseCode', None, None, ), # 1
    None, # 2
    (3, TType.STRUCT, 'result', (Result, Result.thrift_spec), None, ), # 3
    None, # 4
    (5, TType.STRUCT, 'serverInfo', (ServerInfo, ServerInfo.thrift_spec), None, ), # 5
    (6, TType.LIST, 'details', (TType.STRUCT,(ResponseDetail, ResponseDetail.thrift_spec)), None, ), # 6
  )

  def __init__(self, responseCode=None, serverInfo=None, result=None, details=None,):
    self.responseCode = responseCode
    self.serverInfo = serverInfo
    self.result = result
    self.details = details

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.responseCode = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.serverInfo = ServerInfo()
          self.serverInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.result = Result()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.details = []
          (_etype273, _size270) = iprot.readListBegin()
          for _i274 in range(_size270):
            _elem275 = ResponseDetail()
            _elem275.read(iprot)
            self.details.append(_elem275)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Response')
    if self.responseCode is not None:
      oprot.writeFieldBegin('responseCode', TType.I32, 1)
      oprot.writeI32(self.responseCode)
      oprot.writeFieldEnd()
    if self.result is not None:
      oprot.writeFieldBegin('result', TType.STRUCT, 3)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.serverInfo is not None:
      oprot.writeFieldBegin('serverInfo', TType.STRUCT, 5)
      self.serverInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.details is not None:
      oprot.writeFieldBegin('details', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.details))
      for iter276 in self.details:
        iter276.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.responseCode)
    value = (value * 31) ^ hash(self.serverInfo)
    value = (value * 31) ^ hash(self.result)
    value = (value * 31) ^ hash(self.details)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InstanceConfigRewrite:
  """
  Attributes:
   - instanceKey: Key for the task to rewrite.
   - oldTask: The original configuration.
   - rewrittenTask: The rewritten configuration.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'instanceKey', (InstanceKey, InstanceKey.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'oldTask', (TaskConfig, TaskConfig.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'rewrittenTask', (TaskConfig, TaskConfig.thrift_spec), None, ), # 3
  )

  def __init__(self, instanceKey=None, oldTask=None, rewrittenTask=None,):
    self.instanceKey = instanceKey
    self.oldTask = oldTask
    self.rewrittenTask = rewrittenTask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.instanceKey = InstanceKey()
          self.instanceKey.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.oldTask = TaskConfig()
          self.oldTask.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.rewrittenTask = TaskConfig()
          self.rewrittenTask.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InstanceConfigRewrite')
    if self.instanceKey is not None:
      oprot.writeFieldBegin('instanceKey', TType.STRUCT, 1)
      self.instanceKey.write(oprot)
      oprot.writeFieldEnd()
    if self.oldTask is not None:
      oprot.writeFieldBegin('oldTask', TType.STRUCT, 2)
      self.oldTask.write(oprot)
      oprot.writeFieldEnd()
    if self.rewrittenTask is not None:
      oprot.writeFieldBegin('rewrittenTask', TType.STRUCT, 3)
      self.rewrittenTask.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.instanceKey)
    value = (value * 31) ^ hash(self.oldTask)
    value = (value * 31) ^ hash(self.rewrittenTask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobConfigRewrite:
  """
  Attributes:
   - oldJob: The original job configuration.
   - rewrittenJob: The rewritten job configuration.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'oldJob', (JobConfiguration, JobConfiguration.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'rewrittenJob', (JobConfiguration, JobConfiguration.thrift_spec), None, ), # 2
  )

  def __init__(self, oldJob=None, rewrittenJob=None,):
    self.oldJob = oldJob
    self.rewrittenJob = rewrittenJob

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.oldJob = JobConfiguration()
          self.oldJob.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.rewrittenJob = JobConfiguration()
          self.rewrittenJob.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobConfigRewrite')
    if self.oldJob is not None:
      oprot.writeFieldBegin('oldJob', TType.STRUCT, 1)
      self.oldJob.write(oprot)
      oprot.writeFieldEnd()
    if self.rewrittenJob is not None:
      oprot.writeFieldBegin('rewrittenJob', TType.STRUCT, 2)
      self.rewrittenJob.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.oldJob)
    value = (value * 31) ^ hash(self.rewrittenJob)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConfigRewrite:
  """
  Attributes:
   - jobRewrite
   - instanceRewrite
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'jobRewrite', (JobConfigRewrite, JobConfigRewrite.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'instanceRewrite', (InstanceConfigRewrite, InstanceConfigRewrite.thrift_spec), None, ), # 2
  )

  def __init__(self, jobRewrite=None, instanceRewrite=None,):
    self.jobRewrite = jobRewrite
    self.instanceRewrite = instanceRewrite

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.jobRewrite = JobConfigRewrite()
          self.jobRewrite.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.instanceRewrite = InstanceConfigRewrite()
          self.instanceRewrite.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfigRewrite')
    if self.jobRewrite is not None:
      oprot.writeFieldBegin('jobRewrite', TType.STRUCT, 1)
      self.jobRewrite.write(oprot)
      oprot.writeFieldEnd()
    if self.instanceRewrite is not None:
      oprot.writeFieldBegin('instanceRewrite', TType.STRUCT, 2)
      self.instanceRewrite.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobRewrite)
    value = (value * 31) ^ hash(self.instanceRewrite)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RewriteConfigsRequest:
  """
  Attributes:
   - rewriteCommands
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'rewriteCommands', (TType.STRUCT,(ConfigRewrite, ConfigRewrite.thrift_spec)), None, ), # 1
  )

  def __init__(self, rewriteCommands=None,):
    self.rewriteCommands = rewriteCommands

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.rewriteCommands = []
          (_etype280, _size277) = iprot.readListBegin()
          for _i281 in range(_size277):
            _elem282 = ConfigRewrite()
            _elem282.read(iprot)
            self.rewriteCommands.append(_elem282)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RewriteConfigsRequest')
    if self.rewriteCommands is not None:
      oprot.writeFieldBegin('rewriteCommands', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.rewriteCommands))
      for iter283 in self.rewriteCommands:
        iter283.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rewriteCommands)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
